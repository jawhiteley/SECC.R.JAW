Factor
Factor <- factor( rep( c(2, 1), 10) , levels = c(2, 1) )
levels(Factor) <- list( "level 1"=1, "level 2"=2 )	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( rep( c(2, 1), 10) , levels = c(2, 1) )
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ) )	# safely reorder factor levels.
Factor
Factor <- factor( rep( c(2, 1), 10) , levels = c(2, 1) )
levels(Factor) <- list( "level 1"=1, "level 2"=2 )	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ) )	# safely reorder factor levels.
Factor
Factor <- factor( Factor, levels=c( 'level 2', 'level 1' ) )	# safely reorder factor levels.
Factor
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ), labels = c('level A', 'level B') )	# safely reorder (existing) factor levels AND re-name labels.
Factor
Factor <- factor( rep( c(2, 1, 3), 10) , levels = c(3, 2, 1) )
Factor
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 )	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( rep( c(2, 1, 3, 4), 5) , levels = c(4, 3, 2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 , 3)	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( Factor, levels=c( 'level 2', 'level 1' ) )	# safely reorder factor levels.
Factor
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ), labels = c('level A', 'level B') )	# safely reorder (existing) factor levels AND re-name labels.
Factor
?factor
Factor <- factor( rep( c(2, 1, 3, 4), 5) , levels = c(4, 3, 2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 , 3)	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor <- factor( Factor, levels=c( 'level 2', 'level 1', '', 'level 4' ) )	# safely reorder factor levels.
Factor
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ), labels = c('level A', 'level B') )	# safely reorder (existing) factor levels AND re-name labels.
Factor
Factor <- factor( rep( c(2, 1, 3, 4), 5) , levels = c(4, 3, 2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 , 3)	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( Factor, levels=c( 'level 4', '', 'level 2', 'level 1' ) )	# safely reorder factor levels (doesn't change data values).
Factor
Factor <- factor( rep( c(2, 1, 3, 4), 5) , levels = c(4, 3, 2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 , 3, "level 9"=9)	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
?plot
?methods
methods(
"call")
methods(call)
?call
?expression
demo(plotmath)
?plotmath
## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
 ## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
require(graphics)#
#
x <- seq(-4, 4, len = 101)#
y <- cbind(sin(x), cos(x))#
matplot(x, y, type = "l", xaxt = "n",#
        main = expression(paste(plain(sin) * phi, "  and  ",#
                                plain(cos) * phi)),#
        ylab = expression("sin" * phi, "cos" * phi), # only 1st is taken#
        xlab = expression(paste("Phase Angle ", phi)),#
        col.main = "blue")#
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))
## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)
?bquote
a <- 2#
#
bquote(a == a)#
quote(a == a)#
#
bquote(a == .(a))#
substitute(a == A, list(A = a))#
#
plot(1:10, a*(1:10), main = bquote(a == .(a)))
rm(list=ls())	# clear memory
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/SECC.functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC - ARA data.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA2_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
ls()
summary(Yp.aov)		# summary statistics
str(SECC)
head(SECC)
str(SECC)
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC - ARA data.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )
str(SECC)
str(SECC.full)
head(SECC)
head(SECC.full)
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC - ARA data.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
head(SECC)
SECC.full[SECC.full$Sample=="41A-1.1, ]
"
SECC.full[SECC.full$Sample=="41A-1.1", ]
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
rm(list=ls())	# clear memory
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
summary(Yp.aov)		# summary statistics
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
summary(Yp.aov)		# summary statistics
head(SECC)
?sprintf
?options
options()
par("ask")
?par
txt <- "Hello World ±#
123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890"
x1 <- expression( mu*"mol" %*% m^-2 )
x2 <- expression( d^-1 )
x.text  <- "Label Text"
text <- bquote( paste( .(x.text), " (", .(x1), %*%, .(x2), ")" ) )
text <- bquote( paste( .(x.text), " (", .(x1), .(%*%), .(x2), ")" ) )
N[,]<-10 #I think this is equivalent to what Jon wrote N(:,:) - Initial Species Abundances
N<- matrix(0,ncol=numCom,nrow=numSp) #Community x Species abundance matrix(communities as Rows, species as Columns)
N[,]<-10 #I think this is equivalent to what Jon wrote N(:,:) - Initial Species Abundances
numSp<- 5 #number of species
N<- matrix(0,ncol=numCom,nrow=numSp) #Community x Species abundance matrix(communities as Rows, species as Columns)
N[,]<-10 #I think this is equivalent to what Jon wrote N(:,:) - Initial Species Abundances
numCom<- 5 #number of communities
numSp<- 5 #number of species
N<- matrix(0,ncol=numCom,nrow=numSp) #Community x Species abundance matrix(communities as Rows, species as Columns)
N[,]<-10 #I think this is equivalent to what Jon wrote N(:,:) - Initial Species Abundances
N
N<-10
N
source("/tmp/r-plugin-jaw/Rsource-34856-SIH2.0.R")
#SIH Hypothesis ver 2. This time using for for loops
#parameters
Tmax<- 40000
Tdata<- seq(1, Tmax)
DT<- 0.08 # % size of discrete "time steps"- Mouquet most recently used 0.08, although 0.001 is presented in AmNat 2003
numCom<- 5 #number of communities
numSp<- 5 #number of species
N<- matrix(0,ncol=numCom,nrow=numSp) #Community x Species abundance matrix(communities as Rows, species as Columns)
Ext<- 0.1 #extinction Threshold
rInput<-150
rLoss<-10
eff<-0.2
mort<-0.2
disp<-0.04
ePeriod<-40000 #period of env sinusoidal fluctuations
eAMP<-1 #amplitude of envrionment sinusoidal fluctuations- persistence of one species ~0.835
eOptimum<-seq(0,eAMP, by=1/(numSp-1)) #I flipped this around from the model - don't know if it makes a difference
#eOptima<-matrix(eOptimum,numCom,1) #this isn't working properly
#initial conditions
N[,]<-10 #I think this is equivalent to what Jon wrote N(:,:) - Initial Species Abundances
N0<-N
Nt<-N
envt0<-seq(0,eAMP, 1/(numCom-1)) #Initial environmental states for asynchronous environmental fluctuations between patches/communities - I flipped this around as well
envt<-envt0
res0<-matrix(0,numCom,1)
res0[,]<-10 #initial resource abundance
res<-res0
Rt<-res
initM<-cbind(envt0,res0,N0)
NdataM<-initM
init<-c(envt0,res0,N0) #monster vector of initial conditions
Ndata<-init
#initialize environment asynchronously (different phase) between 0 and 1 within sin wave
#make mod function
mod<-function(x,m)
{
  t1<-floor(x/m)
  return(x-t1*m)
}
envtini<-matrix(0,1,numCom)
for(j in 1:numCom)
    if(mod(j,2)==0) # half the communities have environments going in opposite directions to enable asynchrony over entire period, instead of only half the sin wave.
        {envtini[j] <- pi - asin((2*(eOptimum[j]/eAMP)) -1)
        } else{envtini[j] <- asin((2*(eOptimum[j]/eAMP)) -1)
        }
consume<-matrix(0,numCom,numSp)
migrants<-matrix(0,numCom,numSp)
#ODE System - no idea what this is - ask Jon
for(t in 1:Tmax){
  for(i in 1:numSp){
    migrants[,i]<-sum(N[,i]) #important to do this BEFORE updating dynamics, otherwise values will update in an inappropriate order
    for(j in 1:numCom){
      migrants[j,i]<-migrants[j,i] - N[j,i] #important to do this BEFORE updating dynamics, otherwise values will update in an inappropriate order
      }
      #model - not sure if part after extinction Threshold should be in this loop
      for(j in 1:numCom){
        envt[j]<-((sin(envtini[j] + 2*pi*t/ePeriod)+1)/2)*eAMP #Environmental state at current timestep [* Amplitude]
        for(i in 1:numSp){
          consume[j,i]<-(1.5 - abs(eOptimum[i] - envt[j]))/10
          Nt[j,i] <- N[j,i] +( (eff*consume[j,i]*res[j] - mort)*N[j,i] + disp*( migrants[j,i]/(numCom-1) ) - disp*N[j,i] ) *DT # Consumers + dispersal
          }
          Rt[j] = res[j] + (rInput - rLoss*res[j] - res[j] * (sum(consume[j,]*N[j,]) ) )*DT # Resources
      }
      Nextinct<- Nt>Ext #Extinction threshold
      N<-Nt*Nextinct;   # set N to new value - multiply each item in the matrix by either 1 (not extinct) or 0(extinct)
      res<- Rt # set res to new value
      #Com1<-matrix(NA, nrow=Tmax, ncol=numSp)
      #Com1[t,]<-N[,1] #attempt to get community 1 to print out - one row for each time step
      #DataRow<-c(envt,res,N)
      #Ndata[t,]<-DataRow #Store Output for this timestep
}
plot(Com1[,1]~Tdata)
N
str(Com)
ls()
str(Nt)
str(Tdata)
str(Ndata)
N[,]<-10 #I think this is equivalent to what Jon wrote N(:,:) - Initial Species Abundances
N
N[,1}
N[,]
N[,1]
source("/tmp/r-plugin-jaw/Rsource-34856-SIH2.0.R")
ls()
str(N)
N
source("/tmp/r-plugin-jaw/Rsource-34856-SIH2.0.R")
plot(Com1[,1]~Tdata, type='line')
plot(Com1[,1]~Tdata, type='l')
getwd()  # Check that we're in the right place
?seq
source("/tmp/r-plugin-jaw/Rsource-49287-SIH2.02.R")
par(mfrow=c(3,1))#
#
plot(Com1[,1]~Tdata, type='l', ylim=c(0,100), main=disp)#
for(i in 2:numSp){#
  lines(Com1[,i]~Tdata, col=i)#
  }#
  #
plot(Env1[,1]~Tdata, type='l', main="Environment")#
#for(i in 2:numSp){#
    #lines(Env1[,i]~Tdata, col=i)#
    #}#
#
plot(consume1[,1]~Tdata, type='l', main="consume")
str(Com1)
> plot(Com1[,]~Tdata, type='l', ylim=c(0,100), main=disp)
 plot(Com1[,]~Tdata, type='l', ylim=c(0,100), main=disp)
 plot(Com1, type='l', ylim=c(0,100), main=disp)
 plot( Tdata, Com1, type='l', ylim=c(0,100), main=disp)
?xy.plot
?plot.xy
?plot.ts
?plot
?plotmap
??plotmap
?eps
??eps
?pdf
?postscript
help("setEPS")
cite()
citation()
citation(ggplot2)
citation("ggplot2")
citation("lme4")
citation("reshape")
citation("Rcmdr")
packages()
help.start()
install.packages("Rcmdr")
citation("Rcmdr")
source("/tmp/r-plugin-jaw/Rsource-41695-Cyanobacteria.R")
  setwd("./ SECC/")  # relative to my usual default wd in R GUI (Mac).
  getwd()  # Check that we're in the right place
source("/tmp/r-plugin-jaw/Rsource-41695-Cyanobacteria.R")
source("/tmp/r-plugin-jaw/Rsource-41645-ARA~cyanobacteria.R")
source("/tmp/r-plugin-jaw/Rsource-41645-ARA~cyanobacteria.R")
source("/tmp/r-plugin-jaw/Rsource-41645-ARA~cyanobacteria.R")
source("/tmp/r-plugin-jaw/Rsource-41645-ARA~cyanobacteria.R")
source('./lib/init.R')
str(SECC)
source("/tmp/r-plugin-jaw/Rsource-41896-Cyanobacteria.R")
