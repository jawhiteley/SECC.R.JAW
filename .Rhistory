pos.all.sort  <- c("O", "I", "N", "S", "E", "W") # desired sort order.#
pos.lvls      <- c("I", "S/N", "W/E", "O")	# S/N is for alphabetical sorting.  Do not change.#
pos.sort      <- c("O", "I", "S/N", "W/E")	# S/N is for alphabetical sorting.  Do not change.#
pos.labels    <- c("Inner", "Other", "Outer")#
pos.precip    <- c("Wet", "Mesic", "Dry")#
sort.order <- c("Time.pt", "Block","Chamber", "Frag") # not including "pos" or "position"#
  # The nesting structure puts "Block" first (largest experimental unit).#
  # I tend to sort by Time.pt first, however.#
SECC.grid <- expand.grid( #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Chamber=Chamber.lvls, #
                          Frag=Frag.lvls, #
                          pos=pos.sort, #
                          KEEP.OUT.ATTRS = FALSE #
                        )#
SECC.sorted <- sort_df( SECC.grid, #
  vars=c(sort.order, "pos") #
) #
  # useful for wholesale sorting, but I really want the position column in a particular, non-alphabetical order (which is used for data entry).  #
  # unless, I can use the factor codes for pos, rather than the levels. ***#
  # The columns will be re-ordered in the next step anyway.#
str(SECC.sorted)#
head(SECC.sorted)#
  #
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels = pos.lvls),#
  stringsAsFactors = FALSE#
)  )#
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?#
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position, levels=pos.all.sort),  # levels in sort order#
  stringsAsFactors = FALSE#
) )#
  # O(uter), I(nner), N/S, E/W#
  # This is mostly to facilitate data processing & entry, which typically occurs in this order.#
  # Sorting a data frame actually uses the numeric codes for factors, not the levels.  #
  # So, I just have to re-order the levels to be in the order I want the values to be sorted in.#
PatchIDs.sort <- sort_df( PatchIDs, #
  vars=c(sort.order, "position") #
)#
str(PatchIDs.sort)#
head(PatchIDs.sort)
Rows_mismatched <- sum(#
  SECC.base$Block   != PatchIDs.sort$Block   |#
  SECC.base$Time.pt != PatchIDs.sort$Time.pt |#
  SECC.base$Chamber != PatchIDs.sort$Chamber |#
  SECC.base$Frag    != PatchIDs.sort$Frag#
)	# rows where columns are mismatched.  Should be 0#
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(PatchIDs.sort$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")#
IDs_mismatched <- sum( SECC.merged$SampleID != PatchIDs.sort$PatchID )#
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs (especially sorting) and try again.")
str(SECC.merged)
head(SECC.merged)
str(SECC.merged)
invisible(edit(SECC.merged))
write.csv( SECC.merged, file="SECC-base.csv" )
?cat
Rows_mismatched <- sum(#
  SECC.base$Block   != Positions$Block   |#
  SECC.base$Time.pt != Positions$Time.pt |#
  SECC.base$Chamber != Positions$Chamber |#
  SECC.base$Frag    != Positions$Frag#
)	# rows where columns are mismatched.  Should be 0
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position, levels=pos.all.sort),  # levels in sort order#
  stringsAsFactors = FALSE#
) )#
  # O(uter), I(nner), N/S, E/W#
  # This is mostly to facilitate data processing & entry, which typically occurs in this order.#
  # Sorting a data frame actually uses the numeric codes for factors, not the levels.  #
  # So, I just have to re-order the levels to be in the order I want the values to be sorted in.#
Positions <- sort_df( PatchIDs, #
  vars=c(sort.order, "position") #
)#
str(Positions)#
head(Positions)
Rows_mismatched <- sum(#
  SECC.base$Block   != Positions$Block   |#
  SECC.base$Time.pt != Positions$Time.pt |#
  SECC.base$Chamber != Positions$Chamber |#
  SECC.base$Frag    != Positions$Frag#
)	# rows where columns are mismatched.  Should be 0#
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(Positions$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")#
IDs_mismatched <- sum( SECC.merged$SampleID != Positions$PatchID )#
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs (especially sorting) and try again.")#
str(SECC.merged)#
head(SECC.merged)#
rm(list=ls())	# clear memory#
	# replace file.choose() with a path in quotes "".#
	# file.choose() opens a file browser: can't choose a folder per se, but maybe it won't mind if a file is specified?#
getwd()	# check that we're in the right place.#
#
library(car)	# load external package 'car', for recode()#
library(reshape)	# sort_df (sort data frame) wrapper for order#
#
#
Block.lvls    <- as.integer( seq(1, 8) )#
Time.pt.lvls  <- as.integer( seq(1, 4) )#
Chamber.lvls  <- c("A", "B", "C")#
Chamber.labels<- c("Ambient", "Partial Chamber", "Full Chamber")#
Chamber.Heat  <- c("Ambient", "Warm", "Hot")#
Frag.lvls     <- as.integer( seq(1, 4) )#
Frag.labels   <- c("Contiguous", "Full Corridors", "Pseudo-Corridors", "Isolated")#
pos.old.lvls  <- c( 1 , "S", "W", "E", "N",  0 )  # I used to use 0 & 1 for 'Outer' & 'Inner', respectively.#
pos.all.lvls  <- c("I", "S", "W", "E", "N", "O")#
pos.all.sort  <- c("O", "I", "N", "S", "E", "W") # desired sort order.#
pos.lvls      <- c("I", "S/N", "W/E", "O")	# S/N is for alphabetical sorting.  Do not change.#
pos.sort      <- c("O", "I", "S/N", "W/E")	# S/N is for alphabetical sorting.  Do not change.#
pos.labels    <- c("Inner", "Other", "Outer")#
pos.precip    <- c("Wet", "Mesic", "Dry")#
sort.order <- c("Time.pt", "Block", "Chamber", "Frag") # not including "pos" or "position"#
  # The nesting structure puts "Block" first (largest experimental unit).#
  # I tend to sort by Time.pt first, however,#
  # To reflect the order in which samples were actually collected & processed.#
SECC.grid <- expand.grid( #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Chamber=Chamber.lvls, #
                          Frag=Frag.lvls, #
                          pos=pos.sort, #
                          KEEP.OUT.ATTRS = FALSE #
                        )#
SECC.sorted <- sort_df( SECC.grid, #
  vars=c(sort.order, "pos") #
) #
  # useful for wholesale sorting, but I really want the position column in a particular, non-alphabetical order (which is used for data entry).  #
  # unless, I can use the factor codes for pos, rather than the levels. ***#
  # The columns will be re-ordered in the next step anyway.#
str(SECC.sorted)#
head(SECC.sorted)#
  #
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels = pos.lvls),#
  stringsAsFactors = FALSE#
)  )#
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?#
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?#
#
#
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position, levels=pos.all.sort),  # levels in sort order#
  stringsAsFactors = FALSE#
) )#
  # O(uter), I(nner), N/S, E/W#
  # This is mostly to facilitate data processing & entry, which typically occurs in this order.#
  # Sorting a data frame actually uses the numeric codes for factors, not the levels.  #
  # So, I just have to re-order the levels to be in the order I want the values to be sorted in.#
Positions <- sort_df( PatchIDs, #
  vars=c(sort.order, "position") #
)#
str(Positions)#
head(Positions)#
Rows_mismatched <- sum(#
  SECC.base$Block   != Positions$Block   |#
  SECC.base$Time.pt != Positions$Time.pt |#
  SECC.base$Chamber != Positions$Chamber |#
  SECC.base$Frag    != Positions$Frag#
)	# rows where columns are mismatched.  Should be 0#
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(Positions$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")#
IDs_mismatched <- sum( SECC.merged$SampleID != Positions$PatchID )#
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs (especially sorting) and try again.")#
str(SECC.merged)#
head(SECC.merged)#
write.csv( SECC.merged, file="SECC-base.csv" )
library(help = car)
save.ls <- c(#
  'Block.lvls',#
  'Time.pt.lvls',#
  'Chamber.lvls', 'Chamber.labels', 'Chamber.Heat',#
  'Frag.lvls', 'Frag.labels',#
  'pos.old.lvls', 'pos.all.lvls', 'pos.all.sort', #
  'pos.labels', 'pos.precip', #
  'Trt.nest.order', 'Trt.sort.order'#
)
Trt.nest.order <- c("Block", "Time.pt","Chamber", "Frag", "pos")#
Trt.sort.order <- c("Time.pt", "Block", "Chamber", "Frag") # not including "pos" or "position"
rm(list=ls())	# clear memory#
	# replace file.choose() with a path in quotes "".#
	# file.choose() opens a file browser: can't choose a folder per se, but maybe it won't mind if a file is specified?#
getwd()	# check that we're in the right place.#
#
library(car)	# load external package 'car', for recode()#
library(reshape)	# sort_df (sort data frame) wrapper for order#
#
#
save.ls <- c(#
  'Block.lvls',#
  'Time.pt.lvls',#
  'Chamber.lvls', 'Chamber.labels', 'Chamber.Heat',#
  'Frag.lvls', 'Frag.labels',#
  'pos.old.lvls', 'pos.all.lvls', 'pos.all.sort', #
  'pos.labels', 'pos.precip', #
  'Trt.nest.order', 'Trt.sort.order'#
)#
Block.lvls    <- as.integer( seq(1, 8) )#
Time.pt.lvls  <- as.integer( seq(1, 4) )#
Chamber.lvls  <- c("A", "B", "C")#
Chamber.labels<- c("Ambient", "Partial Chamber", "Full Chamber")#
Chamber.Heat  <- c("Ambient", "Warm", "Hot")#
Frag.lvls     <- as.integer( seq(1, 4) )#
Frag.labels   <- c("Contiguous", "Full Corridors", "Pseudo-Corridors", "Isolated")#
pos.old.lvls  <- c( 1 , "S", "W", "E", "N",  0 )  # I used to use 0 & 1 for 'Outer' & 'Inner', respectively.#
pos.all.lvls  <- c("I", "S", "W", "E", "N", "O")#
pos.all.sort  <- c("O", "I", "N", "S", "E", "W") # desired sort order.#
pos.lvls      <- c("I", "S/N", "W/E", "O")	# S/N is for alphabetical sorting.  Do not change.#
pos.sort      <- c("O", "I", "S/N", "W/E")	# S/N is for alphabetical sorting.  Do not change.#
pos.labels    <- c("Inner", "Other", "Outer")#
pos.precip    <- c("Wet", "Mesic", "Dry")#
Trt.nest.order <- c("Block", "Time.pt","Chamber", "Frag", "pos")#
Trt.sort.order <- c("Time.pt", "Block", "Chamber", "Frag") # not including "pos" or "position"#
  # The nesting structure puts "Block" first (largest experimental unit).#
  # I tend to sort by Time.pt first, however,#
  # To reflect the order in which samples were actually collected & processed.#
SECC.grid <- expand.grid( #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Chamber=Chamber.lvls, #
                          Frag=Frag.lvls, #
                          pos=pos.sort, #
                          KEEP.OUT.ATTRS = FALSE #
                        )#
SECC.sorted <- sort_df( SECC.grid, #
  vars=c(Trt.sort.order, "pos") #
) #
  # useful for wholesale sorting, but I really want the position column in a particular, non-alphabetical order (which is used for data entry).  #
  # unless, I can use the factor codes for pos, rather than the levels. ***#
  # The columns will be re-ordered in the next step anyway.#
str(SECC.sorted)#
head(SECC.sorted)#
  #
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels = pos.lvls),#
  stringsAsFactors = FALSE#
)  )#
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?#
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?#
#
#
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position, levels=pos.all.sort),  # levels in sort order#
  stringsAsFactors = FALSE#
) )#
  # O(uter), I(nner), N/S, E/W#
  # This is mostly to facilitate data processing & entry, which typically occurs in this order.#
  # Sorting a data frame actually uses the numeric codes for factors, not the levels.  #
  # So, I just have to re-order the levels to be in the order I want the values to be sorted in.#
Positions <- sort_df( PatchIDs, #
  vars=c(Trt.sort.order, "position") #
)#
str(Positions)#
head(Positions)#
Rows_mismatched <- sum(#
  SECC.base$Block   != Positions$Block   |#
  SECC.base$Time.pt != Positions$Time.pt |#
  SECC.base$Chamber != Positions$Chamber |#
  SECC.base$Frag    != Positions$Frag#
)	# rows where columns are mismatched.  Should be 0#
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(Positions$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")#
IDs_mismatched <- sum( SECC.merged$SampleID != Positions$PatchID )#
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs (especially sorting) and try again.")#
str(SECC.merged)#
head(SECC.merged)#
write.csv( SECC.merged, file="SECC-base.csv" )
save( list=c( SECC.base, save.ls ), file="SECC_factors.R" )
save( list=c( 'SECC.base', save.ls ), file="SECC_factors.R" )
load("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Data/Data Template/Output/SECC_factors.R")
ls()
Frag.labels
getwd()             # check current wd
setwd("./ SECC/")	# Project Directory.
getwd()             # check current wd
load('./save/SECC_factors.R')	# includes SECC.base data.frame
Pos.all.lvls
Pos_all_lvls
Chamber_lvls
Chamber_labels
Pos_lvls
ls()
Pos_labels
Pos_all_lvls %in% Pos_all_sort
Pos_all_lvls == Pos_all_sort
Pos_old_lvls %in% Pos_all_sort
Pos_old_lvls %in% Pos_all_lvls
if ( levels(Pos) %in% Pos_all_lvls) {#
  #
}
if ( levels(SECC.base$Pos) %in% Pos_all_lvls) {#
  #
}
?or
??or
??boolean
ls()
Trt_nest_order
c(NULL, 1)
Data_files <- dir('./data/')#
Data_objects <- NULL#
for (File_name in Data_files) {#
  File_path <- paste("./data/", File_name, sep="")#
  temp <- read.csv(File_path)#
  Object_name <- cleanVarName(File_name)#
  # remove file extension from the object name  #
  Object_name <- gsub("\\.csv\\b", "", Object_name, perl=TRUE ) #
  # assign data to object with similar name as the file.#
  assign(Object_name, temp)#
  # collect a list of object names for further processing.#
  Data_objects <- c(Data_objects, Object_name)#
}#
rm( list=c('File_name', 'File_path','temp','Object_name') )
source("./lib/fun.R")   # define functions
library(car)		# load external package 'car', for recode()
load('./save/SECC_factors.R')	# includes SECC.base data.frame, #
  # and other vectors of standard column names and levels.#
SECC.raw <- read.csv("./save/SECC_base.csv") # just to check how it is imported.  #
  # Should be the same values as SECC.base, but raw column types (only character columns are factors).#
Data_files <- dir('./data/')#
Data_objects <- NULL#
for (File_name in Data_files) {#
  File_path <- paste("./data/", File_name, sep="")#
  temp <- read.csv(File_path)#
  Object_name <- cleanVarName(File_name)#
  # remove file extension from the object name  #
  Object_name <- gsub("\\.csv\\b", "", Object_name, perl=TRUE ) #
  # assign data to object with similar name as the file.#
  assign(Object_name, temp)#
  # collect a list of object names for further processing.#
  Data_objects <- c(Data_objects, Object_name)#
}#
rm( list=c('File_name', 'File_path','temp','Object_name') )
Data_objects
if ( colnames(SECC.base) %in% ColNames_std ) {#
  #
}
ColNames_std <- Trt_nest_order
if ( colnames(SECC.base) %in% ColNames_std ) {#
  #
}
help.start()
min(c(TRUE, FALSE, FALSE, TRUE))
max(c(TRUE, FALSE, FALSE, TRUE))
min(c(TRUE, TRUE))
Trt_nest_order
if (  min( colnames(SECC.base) %in% ColNames_std ) == 0 ) {#
  # min(boolean_vector) == 0 means there was at least on FALSE result#
  # check for most likely non-standard names#
  # rename if possible#
  # if it still fails, throw an Error message: this file needs Special Attention.#
}
?DataFrame
data()
ls()
Trt <- nest <- order
Trt_nest_order
cat("foo")
stop( paste( "foo \n", "bar"))
stop( paste( "foo \r", "bar"))
stop( paste( "foo \n", "     bar"))
stop( paste( "foo \n", "      bar"))
ls()
Trt_nest_order
help.start()
?assign
?get
c("foo", "1") %in% c("2", "foo", "bar")
Rebuilding the help.search() database ...
x <- array(1 : 24, c(2, 3, 4))
slice.index(x, 2)
"foo" %in% c("2", "foo", "bar")
Pos <- lvls
Pos_lvls
Pos_all_lvls
typeof(SECC.ARA.t1$Block)
typeof(SECC.base$Block)
typeof(SECC.base["Block"])
SECC.base["Block"]
typeof(SECC.base["Block"])
typeof(SECC.base[["Block"]])
as.integer("2")
?as
as("2", "integer")
class(SECC.base[["Block"]])
as.integer("2.2")
as.integer("2.foo")
warnings()
length(warning()
)
as.integer("2.foo")
warnings()
length(warnings())
last.warning
log("a)
"
)
warningMessage()
conditionMessage()
log(-1)
class(SECC.base[[Time]])
class(SECC.base[["Time"]])
Pos_old_lvls
Pos_lvls
Pos_all_lvls
levels(SECC["Block"])
levels(SECC.base["Block"])
levels(SECC.base[["Block"]])
stop(
      cat("ERROR: the first argument of the checkSECCdata function", 
          "must be an object of class \"data.frame\"."
         )
     )

stop(
      paste("ERROR: the first argument of the checkSECCdata function", 
          "must be an object of class \"data.frame\".",
         )
     )

stop(
      paste("ERROR: the first argument of the checkSECCdata function", 
          "must be an object of class \"data.frame\"."
         )
     )

numrows(SECC.base)
rows(SECC.base)
dims(SECC.base)
dim(SECC.base)
ls()
class(SECC[["SampleID"]])
class(SECC.base[["SampleID"]])
?args
?arg
str(SECC.raw)
str(SECC.base)
colnames(SECC.raw)
colnames(SECC.raw)["SampleID"]
colnames(SECC.raw)[["SampleID"]]
colnames(SECC.raw)[1] <- "PatchID"
colnames(SECC.raw)
colnames(SECC.raw)[1] <- "SampleID"
colnames(SECC.raw)
Data <- objects
Data_objects
Data_objects[left(Data_objects, 4)=="SECC"]
Data_objects[substr(Data_objects, 1, 4)=="SECC"]
Data_objects[substr(Data_objects, 1, 5)=="SECC."]
q()
n
