scatterutil.base
scatterutil.sub
?text
?par
help.start()
getwd()
setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")
setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")
setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")
getwd
getwd()
str(CB.full)
quit(save = "no")
getwd()
setwd('/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis')
quit(save = "no")
source("./ SECC/lib/SECC.functions.R")	#2010-04-14
ls()
SECC.full <- read.csv("SECC - ARA data.csv")	# specify mising values with na.string=""
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# Basic analyses of experimental data#
# Cyanobacteria density @ time 1#
# R v2.10.1		;	2010-05-04#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
library(nlme)		# mixed-effect models
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC - cb counts.csv", na.string=".")	# specify mising values with na.string=""
str(SECC.full)
data(CO2
)
str(CO2)
?attr
attr(CO2, "labels")
class(attr(CO2, "labels"))
names(CO2)
?grep
?clear()
?clear
??clear
?factor
?sapply
lapply(SECC.cyanobacteria, class)
sapply(SECC.cyanobacteria, class)
?apply
?na.action
?boolean
?and
?union
??boolean
?||
?&&
?logic
??logic
?sum
?count
?countif
?grep
?any
    if (1 > 1)#
      TRUE#
    else if (1 < 1)#
      FALSE#
    else#
      Other
    if (1 > 1)#
      TRUE#
    else if (1 < 1)#
      FALSE#
    else#
      "Other"
if (1 > 1)#
      TRUE#
    else if (1 < 1)#
      FALSE#
    else#
      "Other"
if (1 > 1) {#
	TRUE#
} else if (1 < 1) {#
	FALSE#
} else "Other"
?sort_df
?row.names
?strsplit
?mean
?browser
?merge
strsplit( "123", "")
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
?rep
Factor <- factor( rep( c(2, 1), 10) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
Factor
Factor <- factor( rep( c(2, 1), 10) )
levels(Factor) <- list( "level 1"=1, "level 2"=2 )	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( rep( c(2, 1), 10) , levels = c(2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
Factor
Factor <- factor( rep( c(2, 1), 10) , levels = c(2, 1) )
Factor
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
Factor
Factor <- factor( rep( c(2, 1), 10) , levels = c(2, 1) )
levels(Factor) <- list( "level 1"=1, "level 2"=2 )	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( rep( c(2, 1), 10) , levels = c(2, 1) )
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ) )	# safely reorder factor levels.
Factor
Factor <- factor( rep( c(2, 1), 10) , levels = c(2, 1) )
levels(Factor) <- list( "level 1"=1, "level 2"=2 )	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ) )	# safely reorder factor levels.
Factor
Factor <- factor( Factor, levels=c( 'level 2', 'level 1' ) )	# safely reorder factor levels.
Factor
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ), labels = c('level A', 'level B') )	# safely reorder (existing) factor levels AND re-name labels.
Factor
Factor <- factor( rep( c(2, 1, 3), 10) , levels = c(3, 2, 1) )
Factor
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 )	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( rep( c(2, 1, 3, 4), 5) , levels = c(4, 3, 2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 , 3)	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( Factor, levels=c( 'level 2', 'level 1' ) )	# safely reorder factor levels.
Factor
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ), labels = c('level A', 'level B') )	# safely reorder (existing) factor levels AND re-name labels.
Factor
?factor
Factor <- factor( rep( c(2, 1, 3, 4), 5) , levels = c(4, 3, 2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 , 3)	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor <- factor( Factor, levels=c( 'level 2', 'level 1', '', 'level 4' ) )	# safely reorder factor levels.
Factor
Factor <- factor( Factor, levels=c( 'level 1', 'level 2' ), labels = c('level A', 'level B') )	# safely reorder (existing) factor levels AND re-name labels.
Factor
Factor <- factor( rep( c(2, 1, 3, 4), 5) , levels = c(4, 3, 2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 , 3)	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
Factor <- factor( Factor, levels=c( 'level 4', '', 'level 2', 'level 1' ) )	# safely reorder factor levels (doesn't change data values).
Factor
Factor <- factor( rep( c(2, 1, 3, 4), 5) , levels = c(4, 3, 2, 1) )
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
levels(Factor) <- list( "level 1"=1, "level 2"=2 , 3, "level 9"=9)	# rename (and set order of) factor levels using a named list('New'='old') of value pairs.  Unspecified factor levels are dropped, and values replaced with 'NA'.  values with no new values specified are replaced with empty strings.
Factor
?plot
?methods
methods(
"call")
methods(call)
?call
?expression
demo(plotmath)
?plotmath
## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
 ## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
require(graphics)#
#
x <- seq(-4, 4, len = 101)#
y <- cbind(sin(x), cos(x))#
matplot(x, y, type = "l", xaxt = "n",#
        main = expression(paste(plain(sin) * phi, "  and  ",#
                                plain(cos) * phi)),#
        ylab = expression("sin" * phi, "cos" * phi), # only 1st is taken#
        xlab = expression(paste("Phase Angle ", phi)),#
        col.main = "blue")#
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))
## How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)
?bquote
a <- 2#
#
bquote(a == a)#
quote(a == a)#
#
bquote(a == .(a))#
substitute(a == A, list(A = a))#
#
plot(1:10, a*(1:10), main = bquote(a == .(a)))
rm(list=ls())	# clear memory
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/SECC.functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC - ARA data.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA2_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
ls()
summary(Yp.aov)		# summary statistics
str(SECC)
head(SECC)
str(SECC)
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC - ARA data.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )
str(SECC)
str(SECC.full)
head(SECC)
head(SECC.full)
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC - ARA data.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
head(SECC)
SECC.full[SECC.full$Sample=="41A-1.1, ]
"
SECC.full[SECC.full$Sample=="41A-1.1", ]
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
rm(list=ls())	# clear memory
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
summary(Yp.aov)		# summary statistics
###################################################
# Schefferville Experiment on Climate Change (SEC-C)#
# basic analyses of experimental data#
# A(cetylene) R(eduction) A(ssay) (Nitrogen-Fixation) @ time 1#
# R v2.10.1		;	2010-04-14#
###################################################
## INITIALISE#
###################################################
rm(list=ls())	# clear memory#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis")	# Set Working Directory: replace with a path in quotes "".	# iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis")	# JAW-MBP#
library(car)		# load external package 'car', for recode()#
library(lattice)	# mostly for xyplot#
# library(nlme)		# mixed-effect models#
#=================================================#
## DEFINE FUNCTIONS#
#=================================================#
source("./ SECC/lib/jaw.graph_functions.R")	#2010-04-14#
#
###################################################
## LOAD DATA#
###################################################
SECC.full <- read.csv("SECC_ARA_t1.csv")	# specify mising values with na.string=""#
#
## Define Labels#
ARA.label <- expression(sqrt(ARA)*" ("*mu*"mol "*m^-2*d^-1*")" )#
Nfix.label <- expression("N-fixation ("*sqrt(mu*"mol "*m^-2*d^-1)*")" )#
Y.label <- Nfix.label	# response variable label for this script.#
Chamber.label = "Chamber"#
Frag.label = "Fragmentation Treatment"#
pos.label = "patch position"#
dataset.list <- c("SECC", "SECCr")#
dataset.labels <- c( "patch scale", "Regional scale" )#
#
###################################################
## PROCESS DATA: planned#
###################################################
## Generate factor columns, re-order factor levels, etc.#
SECC.full <- within( SECC.full, {	## instead of attach, this places focus within the indicated data frame / object, and returns object with changes applied (in reverse order...)#
	# Generic Response Variable (used in remainder of script)#
		# ARA_md contains values with BOTH blanks & moss controls subtracted#
		# ARA2_md contains values with ONLY blanks (NOT moss controls) subtracted#
	Y <- as.numeric(ARA_md)/3	# 3:1 ratio ARA:N	-	ARA_md #
	## Rename columns /convert to standard informative names for the rest of this script#
	Block 	<- as.factor(Block)#
	TimePt	<- TimePt#
	Warming <- as.factor(Warming)#
	Frag 	<- as.factor(Frag)#
	pos 	<- as.factor(pos)#
	# new factor column with meaningful values#
	Chamber <- as.factor(Warming)#
	levels(Chamber) <- list( 'Ambient'='A', 'Partial Chamber'='B', 'Full Chamber'='C' )	# rename and reorder factor levels to informative names.  Unspecified values converted to 'NA'.#
	## rename and reorder factor levels the easy way - maintains empty values if empty factor specified, otherwise converts to 'NA'.  Requires package 'car'#
	Chamber <- recode( Warming, #
		"'A'='Ambient'; 'B'='Partial Chamber'; 'C'='Full Chamber'; else=''", #
		as.factor.result=TRUE, #
		levels=c( "Ambient", "Partial Chamber", "Full Chamber" ) #
	)#
	levels(Frag) <- list( 'Continuous'=1, 'Full Corridors'=2, 'Pseudo-Corridors'=3, 'Isolated'=4 )#
	pos <- factor(pos, levels=c('1', 'S', 'W', 'E', 'N', '0'))	# safely reorder factor levels#
	levels(pos) <- list( 'I'='1', 'S'='S', 'W'='W', 'E'='E', 'N'='N', 'O'='0' )	# rename some factor levels (omitted levels are dropped and replaced with empty strings)#
	# new factor column with simplified values for patch position#
	pos1 <- recode( pos, #
		"'I'='Inner'; 'O'='Outer'; else='other'", #
		as.factor.result=TRUE, #
		levels=c( "Inner", "other", "Outer" ) #
	)#
})#
#
## Filter data for analysis.  If no filter is desired, retain assignment to new object for consistent naming & reference for the rest of this script.#
SECC.full <- SECC.full[SECC.full$TimePt==1,]	# only one time point at a time (not repeated measures)#
SECC <- SECC.full[SECC.full$SampleControl=="Sample",]	# only rows for samples, exclude controls#
# controls#
ARAc1 <- SECC.full[SECC.full$SampleControl=="control1",]	# filter moss controls (moss only, no gas added)#
ARAc2 <- SECC.full[SECC.full$SampleControl=="Control2",]	# filter 'Blanks' (gas only, no moss)#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
SECCr <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag), mean ) )	# for regional-level analyses (ignoring position)#
SECC <- with( SECC, aggregate( cbind(Y) , by=list(Block=Block, TimePt=TimePt, Chamber=Chamber, Frag=Frag, pos1=pos1), mean ) )	# using cbind() on the response variables allows multiple columns to be summarized, and also preserves column names.#
#
#=================================================#
# PROCESS DATA: unplanned?#
# Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in dataset.list ){#
	assign( dataset,#
		within( get(dataset), {#
			Y <- replace( Y, which( Y<0 ), 0 )	# negative values are problematic for log and other transformations :-(#
			Y.ln  <- log( Y +1 )	# defaults to base e=exp(1).#
			Y.log <- log( Y +1 , 10 )	# base 10. (stdev prop to mean).#
			Y.sqrt <- sqrt( Y )	# useful for Poisson-distributed data (mean prop. to variance).#
			Y.4rt <-Y^(0.25)	# fourth-root#
			Y.use <- Y.sqrt	# assign which column to work with for analyses****#
		})	#
	)#
}#
# Which response variable is being used (for labels)?****#
Y.used <- "Y.sqrt"#
#
###################################################
## CHECK DATA#
###################################################
## Patch analyses#
head(SECC)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECC)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECC)	# summary statistics#
## Regional analyses#
head(SECCr)		# have a peek at the first 6 rows & columns: is this what you expected?#
str(SECCr)		# check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCr)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECC, plot(Y.log ~ Chamber*Frag*pos1, #
	main="Patch") )	# fixed effects only, no nesting#
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:2 ){#
	dataset <- dataset.list[i]#
	with( get(dataset), {#
		hist( Y )#
		hist( Y.log )#
		hist( Y.sqrt )#
		hist( Y.4rt )#
		qqnorm( Y, main=paste("untransformed: ", dataset.labels[i]) )#
		qqline( Y, col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log, main=paste("log10-transformed: ", dataset.labels[i]) )#
		qqline( Y.log, col="grey50" )#
		qqnorm( Y.sqrt, main=paste("sqrt-transformed: ", dataset.labels[i]) )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt, main=paste("4th-root-transformed: ", dataset.labels[i]) )#
		qqline( Y.4rt, col="grey50" )#
	})#
}#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.use ~ Chamber*Frag*pos1 +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Yr.model <- Y.use ~ Chamber*Frag +Error(Block/Chamber/Frag)#
# Mixed Effects model using lme() (package 'nlme')#
Yp.fixed <- Y.use ~ Chamber*Frag*pos1#
Yp.random <- ~1|Block/Chamber/Frag#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECC )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Yr.aov <- aov( Yr.model, data=SECCr )	# regional effects only.#
Yp.lme <- lme( fixed=Yp.fixed, random=Yp.random, data=SECC )#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
	## trellis plots: any pattern across blocks, within frag & chambers?#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECC, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[1]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECC, plot(Y.use ~ Chamber*Frag*pos1) )	# fixed effects only, no nesting#
plot.new()#
# normal distribution?#
with(SECC, qqnorm(resid(Yp.aov$Within), main="Residuals - patch" ) )	# are residuals normally distributed?#
# with(SECC, shapiro.test( resid(Yp.aov$Within) ) )	# are residuals normally distributed?#
par( mfrow=c(1,1) )#
hist(resid(Yp.aov$Within))	# plot residuals#
# with(SECC, shapiro.test( Y.use ) )	# normality?#
#
## REGIONAL analyses#
	xyplot( Y.use ~ Block | Frag + Chamber, data=SECCr, #
		pch=21, col="black", bg="grey", cex=0.8,#
		main = dataset.labels[2]#
	)#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCr, plot(Y.use ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
with(SECCr, qqnorm(resid(Yp.aov$Within), main="Residuals - Regional" ) )	# are residuals normally distributed?#
# par( mfrow=c(1,1) )#
hist(resid(Yr.aov$"Block:Chamber:Frag"))	# plot residuals#
# with(SECCr, shapiro.test( Y.use ) )	# normality?#
#
#
## lme#
plot(Yp.lme)#
hist(resid(Yp.lme))	# plot residuals#
with(SECC, plot(Yp.lme, Y~fitted(.) ) )	# is response a reasonably linear combination of fitted values?#
with(SECC, qqnorm(Yp.lme, ~resid(.)|Block ) )	# are residuals normally distributed within blocks?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)		# summary statistics#
model.tables(Yp.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))	# panel of figures: 2 rows & 2 columns#
with( SECC, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
with( SECC, interaction.plot( pos1, Frag, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECC, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.Cxp <- lsd["Chamber:pos1"]#
#
## Regional analyses#
# names(Yr.aov)#
summary(Yr.aov)		# summary statistics#
model.tables(Yr.aov, "means")	# effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))	# panel of figures: 1 rows & 1 columns#
with( SECCr, interaction.plot( Frag, Chamber, Y.use, ylab=paste("mean of ", Y.used) ) )#
#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.r <- LSD( Yr.aov$"Block:Chamber:Frag", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.FxC <- lsd.r["Chamber:Frag"]#
lsd.r <- LSD( Yr.aov$"Block:Chamber", Yr.model, data=SECCr, alpha=0.05, mode="pairwise" )	# compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.r.C <- lsd.r["Chamber"]#
#
## Mixed Effects Model analysis Results#
# names(Yp.lme)#
# summary(Yp.lme)		# summary statistics#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <-	data.frame( label=levels(SECC$Chamber), col=c("#000000","#000099","#990000"), bg=c("#FFFFFF","#FFFFFF","#FFFFFF"), pch=c(21,23,18), lty=c(3,2,1) )#
	# Ambient = black, open circles with dotted line ; #
	# Partial = blue, open diamonds with dashed line ; #
	# Full	  = red, solid diamond with solid line.#
yrange <- c(0, 8)	# common range of y-axis on plots.  Set to NULL for auto scaling.#
#
## Patch results#
plot.means <- with( SECC, #
	aggregate( cbind( Y.use ), #
		list(pos=pos1, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.Cxp/2), nrow = length(levels(pos)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , pos , Chamber, #
		error.bars="custom", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of patch values ± LSD (95% comparison intervals)",#
		xlab=pos.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## REGIONAL results#
plot.means <- with( SECCr, #
	aggregate( cbind( Y.use ), #
		list(Frag=Frag, Chamber=Chamber), #
		mean #
	) #
)#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
	# using custom plotMeans function, with custom error bars (LSD)#
	plot.error <- matrix( as.numeric(lsd.r.FxC/2), nrow = length(levels(Frag)), ncol = length(levels(Chamber)) )#
	plotMeans( Y.use , Frag , Chamber, #
		error.bars="none", level=plot.error, cex=2, lwd=2,#
		lty=Chamber.map$lty, pch=Chamber.map$pch,#
		col=as.character(Chamber.map$col),#
		bg=as.character(Chamber.map$bg),#
		main="Means of Regional values",#
		xlab=Frag.label, ylab=Y.label, ylim=yrange#
	)	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
# back-transform means - convert to /Ha/Yr#
# lose middle-values (steeper break-out patterns)#
# Ecological implications?#
# RARE event - implications of patchiness#
# also patchy in time: dynamic process?  Do patches move?#
# effect of long-term drought: lose compensatory benefit of cyanobacteria that otherwise makee up for lack of available Nitrogen.
summary(Yp.aov)		# summary statistics
head(SECC)
?sprintf
?options
options()
par("ask")
?par
plot(1:25, 1:25, pch = 1:25)
?interaction.plot
?par
?all
?apply
options('device.ask.default')
devAskNewPage("ask")
devAskNewPage()
###################################################
### Schefferville Experiment on Climate Change (SEC-C)#
### Template for basic analyses of experimental data#
### Response Variable(s)  @ time #s#
### Jonathan Whiteley     R v2.10.1     2011-03-25#
###################################################
## INITIALISE#
###################################################
## Set Working Directory: path in quotes "".#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis/ SECC/")		    # iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis/ SECC/")	# JAW-MBP#
getwd()  # Check that we're in the right place#
#
## Load data, functions, etc.  Includes rm(list=ls()) to clear memory#
source('./lib/init.R')#
library(lattice)	# mostly for xyplot#
library(ggplot2)    # grammar of graphics#
par(ask = FALSE)    # Stop asking me to hit <Return> to see next plot!#
options(device.ask.default = FALSE) # same as above: does this work?#
#
###################################################
## CONFIGURE BASIC ANALYSIS#
###################################################
## Can this script be used in a generic way for#
## most univariate analyses?#
#
##================================================#
## SETTINGS - edit#
##================================================#
#
## Specify which treatment levels to include (by index is probably easiest)#
Time.use     <- levels(SECC$Time)[1]      # Time (index: 1-3) to include in this run#
Chamber.use  <- levels(SECC$Chamber)      # Chamber treatments to include#
Frag.use     <- levels(SECC$Frag)         # Frag treatments to include#
Position.use <- levels(SECC$Position)     # Patch Positions to include#
Y.col        <- 'Nfix'                    # Column to use for response variable.#
#
## Define Labels#
Y.label <- attr(SECC, "labels")[[Y.col]]  # response variable label for this script.#
Y.units <- attr(SECC, "units" )[[Y.col]]  # response variable units for this script.#
Y.units <- bquote( paste( .(Y.label), " (", #
                         sqrt(mu*"mol" %.% m^-2%.%d^-1),  # manually (for now)#
                         ")",#
                         sep=""#
                         )#
                  )#
Dataset.list <- c("SECCp", "SECCmc")#
Dataset.labels <- c( "Patch scale data", "Meta-Community scale data" )#
ID.cols <- c('SampleID', 'Time', 'Block', 'Chamber', 'Frag', 'Pos', 'Position')#
Trt.nested <- c('Time', 'Block', 'Chamber', 'Frag', 'Position')#
#
#
##================================================#
## PREPARE DATA - do not edit#
##================================================#
## strip empty rows (rows with only NAs)?#
empty.rows <- which( apply( SECC[, lapply(SECC, class) == "numeric"], 1,#
                           function(x) all(is.na(x))#
                           )#
                    )#
SECC.use <- SECC[-empty.rows, ]  # !is.na(SECC$Time) ; NAs in factors are annoying#
## SECC.use <- SECC                 # make a copy, for further processing (save the original for reference).#
#
#
##================================================#
## CALCULATIONS - edit#
##================================================#
# str(SECC.use)#
sampleA  <- 6	# sample Area, in cm^2:  pi * (2.75/2)^2 ; pi * (2.8 / 2)^2#
      #     6 for rough estimate of inner tube diameter (2.8 cm): pi*(2.8/2)^2,#
      #  or 6.4 for 20 shoots, based on density survey.#
sample.to.m2 <- (100*100)/sampleA	# scale sample area, in cm^2 to m^2#
sample_ml    <- 50  # 50 ml sample#
ARA.m2	 <- sampleA/(100*100)  # ARA sample area,   in (cm^2 to) m^2#
patchA   <- pi * (12.5^2)      # patch area#
patch.m2 <- patchA/(100*100)   # patch sample area, in (cm^2 to) m^2#
Nfix.ARA.ratio <- 1/3  # ratio of N-fixation : ARA.#
#
SECC.use <- within( SECC.use, {	#
  ## Generic Response Variable (used in remainder of script)#
  Nfix  <- ARA.m * Nfix.ARA.ratio#
  Y <- as.numeric( get(Y.col) )  # do not need to edit this#
  Y[Y < 0] <- 0    ## negative values cause problems for transformations: replace with 0#
  ## change negative ARA values to 0 - should I wait until after aggregation?#
})#
#
#
#
###################################################
## PROCESS DATA: planned#
###################################################
#
## Filter data for analysis, according to settings above.#
SECC.use <- SECC.use[SECC.use$Time     %in% Time.use     &#
                     SECC.use$Chamber  %in% Chamber.use  &#
                     SECC.use$Frag     %in% Frag.use     &#
                     SECC.use$Position %in% Position.use #
                     , ]#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
## Meta-community (regional) -level analyses (ignoring position):#
SECCmc <- SECC_aggregate( SECC.use, trt = 'Frag' )#
#
## aggregate 'other' patch Positions#
SECCp  <- SECC_aggregate( SECC.use, trt = 'Position' )#
#
#
##=================================================#
## PROCESS DATA: unplanned?#
##=================================================#
## Which response variable is being used (for labels)? ****#
Y.use <- "Y.sqrt"#
## plot label for transformed data.#
Y.tlabel <-      paste( Y.use, ": ", Y.label, sep=""  )  # label for transformation plots#
Y.plabel <- expression( paste(Y.label) * " ("* paste(Y.units) * ")" )  # plot label?#
#
## Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in Dataset.list ){#
  DataObject <- get(dataset)#
  DataObject <- within( DataObject, {#
    Y.trans  <- Y                # temporary, for transformations.#
    Y.trans[Y.trans < 0] <- 0        # negative values are problematic for log and other transformations :-(#
    Y.sqrt   <- sqrt( Y.trans )	# useful for Poisson-distributed data (mean prop. to variance).#
    Y.4rt    <- Y.trans^(0.25)   # fourth-root#
    Y.ln     <- log(Y.trans +1)  # defaults to base e=exp(1).#
    Y.log    <- log(Y.trans +1, 10 )	# base 10. (stdev prop to mean).#
    Y.trans  <- get(Y.use)	    # assign which column to work with for analyses ****#
  })	#
  ## attach relevant info to object attributes.#
  attr(DataObject, "response variable") <- Y.col#
  attr(DataObject, "transformation")    <- Y.use#
  assign(dataset, DataObject)#
}#
#
#
###################################################
## CHECK DATA#
###################################################
head(SECCp)     # have a peek at the first 6 rows & columns: is this what you expected?#
str( SECCp)     # check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCp)  # summary statistics#
## Regional analyses#
head(SECCmc)    # have a peek at the first 6 rows & columns: is this what you expected?#
str( SECCmc)    # check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCmc)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECCp, plot(Y.trans ~ Chamber * Frag * Position, #
                  main=Dataset.labels[1], ylab = Y.tlabel#
                  )#
     )	# fixed effects only, no nesting#
##* PROMPT *###
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:length(Dataset.list) ){#
	dataset <- Dataset.list[i]#
	with( get(dataset), {#
		hist( Y,      sub = Dataset.labels[i] )#
		hist( Y.log,  sub = Dataset.labels[i] )#
		hist( Y.sqrt, sub = Dataset.labels[i] )#
		hist( Y.4rt,  sub = Dataset.labels[i])#
		qqnorm( Y,      main = "untransformed",        sub = Dataset.labels[i] )#
		qqline( Y,      col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log,  main = "log10-transformed",    sub = Dataset.labels[i] )#
		qqline( Y.log,  col="grey50" )#
		qqnorm( Y.sqrt, main = "sqrt-transformed",     sub = Dataset.labels[i] )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt,  main = "4th-root-transformed", sub = Dataset.labels[i] )#
		qqline( Y.4rt,  col="grey50" )#
	})#
}#
#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.trans ~ Chamber*Frag*Position +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Ymc.model <- Y.trans ~ Chamber*Frag +Error(Block/Chamber/Frag)#
#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECCp )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Ymc.aov <- aov( Ymc.model, data=SECCmc )	# regional effects only.#
#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
## trellis plots: any pattern across blocks, within frag & chambers?#
xyplot(Y.trans ~ Block | Frag + Chamber, data=SECCp, #
       pch=21, col="black", bg="grey", cex=0.8,#
       main = Dataset.labels[1]#
       )#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## homogeneity of variances?#
with( SECCp, plot(Y.trans ~ Chamber*Frag*Position) )	# fixed effects only, no nesting#
##* PROMPT *###
plot.new()  # put next plot in empty panel?#
## normal distribution?#
Yp.residuals <- resid(Yp.aov$Within)#
with(SECCp, qqnorm( Yp.residuals, main="Residuals", sub=Dataset.labels[1] ) )	# are residuals normally distributed?#
qqline(Yp.residuals,  col="grey50")#
par( mfrow=c(1,1) )#
hist(Yp.residuals)	# plot residuals#
# with(SECCp, shapiro.test( Yp.residuals ) )	# normality?#
#
##================================================#
## REGIONAL analyses#
xyplot( Y.trans ~ Block | Frag + Chamber, data=SECCmc, #
       pch=21, col="black", bg="grey", cex=0.8,#
       main = Dataset.labels[2]#
       )#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCmc, plot(Y.trans ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
##* PROMPT *###
plot.new()  # for stupid "Hit <Return> ..." prompt when going line-by-line :(#
Ymc.residuals <- resid(Ymc.aov$"Block:Chamber:Frag")#
with(SECCmc, qqnorm( Ymc.residuals, main="Residuals", sub=Dataset.labels[2] ) )	# are residuals normally distributed?#
qqline(Ymc.residuals,  col="grey50")#
par( mfrow=c(1,1) )#
hist(Ymc.residuals)	# plot residuals#
# with(SECCmc, shapiro.test( Ymc.residuals ) )	# normality?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)                 # summary statistics#
model.tables(Yp.aov, "means")   # effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))   # panel of figures: 2 rows & 2 columns#
with( SECCp, interaction.plot(Frag, Chamber, Y.trans,#
                              ylab = paste("mean of", Y.use)#
                              )#
     )#
with( SECCp, interaction.plot(Position, Chamber, Y.trans,#
                              ylab=paste("mean of", Y.use)#
                              )#
     )#
with( SECCp, interaction.plot(Position, Frag, Y.trans,#
                              ylab=paste("mean of ", Y.use)#
                              )#
     )#
#
##________________________________________________#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x Pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECCp, alpha=0.05, mode="pairwise" )  # compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.CxP <- lsd["Chamber:Position"]#
lsd.FxP <- lsd["Frag:Position"]#
lsd.CxFxP <- lsd["Chamber:Frag:Position"]#
#
##================================================#
## Regional analyses#
# names(Ymc.aov)#
summary(Ymc.aov)        # summary statistics#
model.tables(Ymc.aov, "means")  # effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))   # panel of figures: 1 rows & 1 columns#
with( SECCmc, interaction.plot( Frag, Chamber, Y.trans,#
                               ylab=paste("mean of ", Y.use)#
                               )#
     )#
#
##________________________________________________#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.mc <- LSD( Ymc.aov$"Block:Chamber:Frag", Ymc.model, data=SECCmc, alpha=0.05, mode="pairwise" )   # compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.mc.FxC <- lsd.mc["Chamber:Frag"]#
lsd.mc <- LSD( Ymc.aov$"Block:Chamber", Ymc.model, data=SECCmc, alpha=0.05, mode="pairwise" )    # compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.mc.C <- lsd.mc["Chamber"]#
#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <- data.frame( label = levels(SECCp$Chamber),#
                          col = c("#000000", "#000099", "#990000"),#
                          bg  = c("#FFFFFF", "#FFFFFF", "#FFFFFF"),#
                          pch = c(21, 23, 18),#
                          lty = c(3, 2, 1)#
                          )#
	## Ambient = black, open circles with dotted line ; #
	## Partial = blue, open diamonds with dashed line ; #
	## Full	  = red, solid diamond with solid line.#
Frag.map    <- data.frame( label = levels(SECCp$Frag),#
                          col = c("#000000", "#666666", "#000099", "#990000"), #
                          bg  = c("#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"), #
                          pch = c(19, 15, 22, 21),#
                          lty = c(1, 2, 3, 3)#
                          )#
	## Continuous         = black, filled circles with solid line ; #
	## Full Corridors     =  grey, filled squares with dashed line ; #
	## Pseudo-Corridors	  = blue, open squares with dotted line.#
	## Isolated	          =  red, open circles with dotted line.#
#
## Patch results: Chamber x Position#
plot.means <- with( SECCp, #
                   aggregate( cbind( Y.trans ), #
                             list(Pos = Position, Chamber = Chamber), #
                             mean #
                             ) #
                   )#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
  ## using custom plotMeans function, with custom error bars (LSD)#
  plot.error <- matrix( as.numeric(lsd.CxP/2),#
                       nrow = length(levels(Pos)),#
                       ncol = length(levels(Chamber))#
                       )#
  plotMeans( Y.trans , Pos , Chamber, #
            error.bars = "custom", level = plot.error, cex = 2, lwd = 2,#
            lty = Chamber.map$lty, pch = Chamber.map$pch,#
            col = as.character(Chamber.map$col),#
            bg  = as.character(Chamber.map$bg),#
            main = "Patch means ± 95% LSD",#
            sub  = "95% comparison intervals (LSD)",#
            xlab = attr(SECC, "labels")[["Pos"]],#
            ylab = Y.units#
            )	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## Patch results: Frag x Position (significant in t4)#
plot.means <- with( SECCp, #
                   aggregate( cbind( Y.trans ), #
                             list(Pos = Position, Frag = Frag), #
                             mean #
                             ) #
                   )#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
  ## using custom plotMeans function, with custom error bars (LSD)#
  plot.error <- matrix( as.numeric(lsd.FxP/2),#
                       nrow = length(levels(Pos)),#
                       ncol = length(levels(Frag))#
                       )#
  plotMeans( Y.trans , Pos , Frag, #
            error.bars = "custom", level = plot.error, cex = 2, lwd = 2,#
            lty = Frag.map$lty, pch = Frag.map$pch,#
            col = as.character(Frag.map$col),#
            bg  = as.character(Frag.map$bg),#
            main = "Patch means ± 95% LSD",#
            sub  = "95% comparison intervals (LSD)",#
            xlab = attr(SECC, "labels")[["Pos"]],#
            ylab = Y.units#
            )	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
##================================================#
## META-COMMUNITY results#
plot.means <- with( SECCmc, #
                   aggregate( cbind( Y.trans ), #
                             list(Frag=Frag, Chamber=Chamber), #
                             mean #
                             ) #
                   )#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
  ## using custom plotMeans function, with custom error bars (LSD)#
  plot.error <- matrix( as.numeric(lsd.mc.FxC/2),#
                       nrow = length(levels(Frag)),#
                       ncol = length(levels(Chamber))#
                       )#
  plotMeans( Y.trans , Frag , Chamber, #
            error.bars="custom", level=plot.error, cex=2, lwd=2,#
            lty=Chamber.map$lty, pch=Chamber.map$pch,#
            col=as.character(Chamber.map$col),#
            bg=as.character(Chamber.map$bg),#
            main = "Meta-Community means ± 95% LSD",#
            sub  = "95% comparison intervals (LSD)",#
            xlab = attr(SECC, "labels")[["Frag"]],#
            ylab = Y.units#
            )	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## Chamber Main Effects#
plot.means <- with( SECCmc, #
                   aggregate( cbind( Y.trans ), #
                             list(Chamber=Chamber), #
                             mean #
                             ) #
                   )#
plot.error <- rep( as.numeric(lsd.mc.C/2), length(levels(plot.means$Chamber)) )#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
  ## using custom plotMeans function, with custom error bars (LSD)#
  plotMeans( Y.trans , Chamber, #
            error.bars="custom", level=plot.error, cex=2, lwd=2,#
            lty=Chamber.map$lty[3], pch=Chamber.map$pch,#
            col=as.character(Chamber.map$col),#
            bg=as.character(Chamber.map$bg),#
            main = "Meta-Community means ± 95% LSD",#
            sub  = "95% comparison intervals (LSD)",#
            xlab = attr(SECC, "labels")[["Chamber"]],#
            ylab = Y.units#
            )	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})
load("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis/ SECC/save/SECC_factors.R")
load("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis/ SECC/save/SECC_data.R")
## Load data, functions, etc.  Includes rm(list=ls()) to clear memory#
source('./lib/init.R')#
library(lattice)	# mostly for xyplot#
library(ggplot2)    # grammar of graphics#
par(ask = FALSE)    # Stop asking me to hit <Return> to see next plot!#
options(device.ask.default = FALSE) # same as above: does this work?
getwd()  # Check that we're in the right place
setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis/ SECC/")	# JAW-MBP
## Load data, functions, etc.  Includes rm(list=ls()) to clear memory#
source('./lib/init.R')#
library(lattice)	# mostly for xyplot#
library(ggplot2)    # grammar of graphics#
par(ask = FALSE)    # Stop asking me to hit <Return> to see next plot!#
options(device.ask.default = FALSE) # same as above: does this work?
###################################################
### Schefferville Experiment on Climate Change (SEC-C)#
### Template for basic analyses of experimental data#
### Response Variable(s)  @ time #s#
### Jonathan Whiteley     R v2.10.1     2011-03-25#
###################################################
## INITIALISE#
###################################################
## Set Working Directory: path in quotes "".#
# setwd("/Users/jonathan/Documents/ My Documents/PhD/Analysis/ SECC/")		    # iMac@McGill#
# setwd("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Analysis/ SECC/")	# JAW-MBP#
getwd()  # Check that we're in the right place#
#
## Load data, functions, etc.  Includes rm(list=ls()) to clear memory#
source('./lib/init.R')#
library(lattice)	# mostly for xyplot#
library(ggplot2)    # grammar of graphics#
par(ask = FALSE)    # Stop asking me to hit <Return> to see next plot!#
options(device.ask.default = FALSE) # same as above: does this work?#
#
###################################################
## CONFIGURE BASIC ANALYSIS#
###################################################
## Can this script be used in a generic way for#
## most univariate analyses?#
#
##================================================#
## SETTINGS - edit#
##================================================#
#
## Specify which treatment levels to include (by index is probably easiest)#
Time.use     <- levels(SECC$Time)[1]      # Time (index: 1-3) to include in this run#
Chamber.use  <- levels(SECC$Chamber)      # Chamber treatments to include#
Frag.use     <- levels(SECC$Frag)         # Frag treatments to include#
Position.use <- levels(SECC$Position)     # Patch Positions to include#
Y.col        <- 'Nfix'                    # Column to use for response variable.#
#
## Define Labels#
Y.label <- attr(SECC, "labels")[[Y.col]]  # response variable label for this script.#
Y.units <- attr(SECC, "units" )[[Y.col]]  # response variable units for this script.#
Y.units <- bquote( paste( .(Y.label), " (", #
                         sqrt(mu*"mol" %.% m^-2%.%d^-1),  # manually (for now)#
                         ")",#
                         sep=""#
                         )#
                  )#
Dataset.list <- c("SECCp", "SECCmc")#
Dataset.labels <- c( "Patch scale data", "Meta-Community scale data" )#
ID.cols <- c('SampleID', 'Time', 'Block', 'Chamber', 'Frag', 'Pos', 'Position')#
Trt.nested <- c('Time', 'Block', 'Chamber', 'Frag', 'Position')#
#
#
##================================================#
## PREPARE DATA - do not edit#
##================================================#
## strip empty rows (rows with only NAs)?#
empty.rows <- which( apply( SECC[, lapply(SECC, class) == "numeric"], 1,#
                           function(x) all(is.na(x))#
                           )#
                    )#
SECC.use <- SECC[-empty.rows, ]  # !is.na(SECC$Time) ; NAs in factors are annoying#
## SECC.use <- SECC                 # make a copy, for further processing (save the original for reference).#
#
#
##================================================#
## CALCULATIONS - edit#
##================================================#
# str(SECC.use)#
sampleA  <- 6	# sample Area, in cm^2:  pi * (2.75/2)^2 ; pi * (2.8 / 2)^2#
      #     6 for rough estimate of inner tube diameter (2.8 cm): pi*(2.8/2)^2,#
      #  or 6.4 for 20 shoots, based on density survey.#
sample.to.m2 <- (100*100)/sampleA	# scale sample area, in cm^2 to m^2#
sample_ml    <- 50  # 50 ml sample#
ARA.m2	 <- sampleA/(100*100)  # ARA sample area,   in (cm^2 to) m^2#
patchA   <- pi * (12.5^2)      # patch area#
patch.m2 <- patchA/(100*100)   # patch sample area, in (cm^2 to) m^2#
Nfix.ARA.ratio <- 1/3  # ratio of N-fixation : ARA.#
#
SECC.use <- within( SECC.use, {	#
  ## Generic Response Variable (used in remainder of script)#
  Nfix  <- ARA.m * Nfix.ARA.ratio#
  Y <- as.numeric( get(Y.col) )  # do not need to edit this#
  Y[Y < 0] <- 0    ## negative values cause problems for transformations: replace with 0#
  ## change negative ARA values to 0 - should I wait until after aggregation?#
})#
#
#
#
###################################################
## PROCESS DATA: planned#
###################################################
#
## Filter data for analysis, according to settings above.#
SECC.use <- SECC.use[SECC.use$Time     %in% Time.use     &#
                     SECC.use$Chamber  %in% Chamber.use  &#
                     SECC.use$Frag     %in% Frag.use     &#
                     SECC.use$Position %in% Position.use #
                     , ]#
#
## Summarize data by means across different (or all) positions to prevent unbalanced effects?#
## Meta-community (regional) -level analyses (ignoring position):#
SECCmc <- SECC_aggregate( SECC.use, trt = 'Frag' )#
#
## aggregate 'other' patch Positions#
SECCp  <- SECC_aggregate( SECC.use, trt = 'Position' )#
#
#
##=================================================#
## PROCESS DATA: unplanned?#
##=================================================#
## Which response variable is being used (for labels)? ****#
Y.use <- "Y.sqrt"#
## plot label for transformed data.#
Y.tlabel <-      paste( Y.use, ": ", Y.label, sep=""  )  # label for transformation plots#
Y.plabel <- expression( paste(Y.label) * " ("* paste(Y.units) * ")" )  # plot label?#
#
## Transformations, calculated columns, etc.  May depend on the results of exploratory graphs (& assumptions), below.#
for ( dataset in Dataset.list ){#
  DataObject <- get(dataset)#
  DataObject <- within( DataObject, {#
    Y.trans  <- Y                # temporary, for transformations.#
    Y.trans[Y.trans < 0] <- 0        # negative values are problematic for log and other transformations :-(#
    Y.sqrt   <- sqrt( Y.trans )	# useful for Poisson-distributed data (mean prop. to variance).#
    Y.4rt    <- Y.trans^(0.25)   # fourth-root#
    Y.ln     <- log(Y.trans +1)  # defaults to base e=exp(1).#
    Y.log    <- log(Y.trans +1, 10 )	# base 10. (stdev prop to mean).#
    Y.trans  <- get(Y.use)	    # assign which column to work with for analyses ****#
  })	#
  ## attach relevant info to object attributes.#
  attr(DataObject, "response variable") <- Y.col#
  attr(DataObject, "transformation")    <- Y.use#
  assign(dataset, DataObject)#
}#
#
#
###################################################
## CHECK DATA#
###################################################
head(SECCp)     # have a peek at the first 6 rows & columns: is this what you expected?#
str( SECCp)     # check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCp)  # summary statistics#
## Regional analyses#
head(SECCmc)    # have a peek at the first 6 rows & columns: is this what you expected?#
str( SECCmc)    # check structure: are the appropriate variables factors, numeric, etc.?#
summary(SECCmc)	# summary statistics#
#
#
###################################################
## EXPLORE: PLOTS#
###################################################
## make some meaningful plots of data to check for predicted (expected) patterns.#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Patch analyses#
with( SECCp, plot(Y.trans ~ Chamber * Frag * Position, #
                  main=Dataset.labels[1], ylab = Y.tlabel#
                  )#
     )	# fixed effects only, no nesting#
##* PROMPT *###
plot.new()	# empty panel#
plot.new()	# empty panel#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## Is the response variable normally-distributed? Check skew in histograms, eyeball linearity on QQ-plots#
for( i in 1:length(Dataset.list) ){#
	dataset <- Dataset.list[i]#
	with( get(dataset), {#
		hist( Y,      sub = Dataset.labels[i] )#
		hist( Y.log,  sub = Dataset.labels[i] )#
		hist( Y.sqrt, sub = Dataset.labels[i] )#
		hist( Y.4rt,  sub = Dataset.labels[i])#
		qqnorm( Y,      main = "untransformed",        sub = Dataset.labels[i] )#
		qqline( Y,      col="grey50" )	# draw line through 1st & 3rd quartiles.#
		qqnorm( Y.log,  main = "log10-transformed",    sub = Dataset.labels[i] )#
		qqline( Y.log,  col="grey50" )#
		qqnorm( Y.sqrt, main = "sqrt-transformed",     sub = Dataset.labels[i] )#
		qqline( Y.sqrt, col="grey50" )#
		qqnorm( Y.4rt,  main = "4th-root-transformed", sub = Dataset.labels[i] )#
		qqline( Y.4rt,  col="grey50" )#
	})#
}#
#
#
###################################################
## DEFINE MODEL FORMULA#
###################################################
# Nested Fixed Effects, with error term for ANOVA using aov() #
Yp.model <- Y.trans ~ Chamber*Frag*Position +Error(Block/Chamber/Frag)#
# ignoring effect of position: 'regional' effects only#
Ymc.model <- Y.trans ~ Chamber*Frag +Error(Block/Chamber/Frag)#
#
#
###################################################
## ANALYSIS: design#
###################################################
Yp.aov <- aov( Yp.model, data=SECCp )	# simple ANOVA with nested fixed effects.  Nesting means an object of type "aovlist" is produced* (therefore regular TukeyHSD & other functions won't work )#
Ymc.aov <- aov( Ymc.model, data=SECCmc )	# regional effects only.#
#
#
###################################################
## CHECK ASSUMPTIONS: analyse residuals, standard diagnostic plots#
###################################################
## anova#
# independence?#
	# experimental design: random position of Frag within Chambers.#
	# possibility of Block gradient (7&8 SW -> 1-6 E:N), which also corresponds roughly to order of samples.#
## Patch analyses#
## trellis plots: any pattern across blocks, within frag & chambers?#
xyplot(Y.trans ~ Block | Frag + Chamber, data=SECCp, #
       pch=21, col="black", bg="grey", cex=0.8,#
       main = Dataset.labels[1]#
       )#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
## homogeneity of variances?#
with( SECCp, plot(Y.trans ~ Chamber*Frag*Position) )	# fixed effects only, no nesting#
##* PROMPT *###
plot.new()  # put next plot in empty panel?#
## normal distribution?#
Yp.residuals <- resid(Yp.aov$Within)#
with(SECCp, qqnorm( Yp.residuals, main="Residuals", sub=Dataset.labels[1] ) )	# are residuals normally distributed?#
qqline(Yp.residuals,  col="grey50")#
par( mfrow=c(1,1) )#
hist(Yp.residuals)	# plot residuals#
# with(SECCp, shapiro.test( Yp.residuals ) )	# normality?#
#
##================================================#
## REGIONAL analyses#
xyplot( Y.trans ~ Block | Frag + Chamber, data=SECCmc, #
       pch=21, col="black", bg="grey", cex=0.8,#
       main = Dataset.labels[2]#
       )#
par( mfrow=c(2,2), cex=0.8)	# panel of figures: 2 rows & 2 columns#
# homogeneity of variances?#
with( SECCmc, plot(Y.trans ~ Chamber*Frag) )	# fixed effects only, no nesting#
# normal distribution?#
##* PROMPT *###
plot.new()  # for stupid "Hit <Return> ..." prompt when going line-by-line :(#
Ymc.residuals <- resid(Ymc.aov$"Block:Chamber:Frag")#
with(SECCmc, qqnorm( Ymc.residuals, main="Residuals", sub=Dataset.labels[2] ) )	# are residuals normally distributed?#
qqline(Ymc.residuals,  col="grey50")#
par( mfrow=c(1,1) )#
hist(Ymc.residuals)	# plot residuals#
# with(SECCmc, shapiro.test( Ymc.residuals ) )	# normality?#
#
#
###################################################
## ANALYSIS: GET RESULTS#
###################################################
## Patch analyses#
# names(Yp.aov)#
summary(Yp.aov)                 # summary statistics#
model.tables(Yp.aov, "means")   # effect sizes#
# Interaction Plots#
par(mfrow=c(2,2))   # panel of figures: 2 rows & 2 columns#
with( SECCp, interaction.plot(Frag, Chamber, Y.trans,#
                              ylab = paste("mean of", Y.use)#
                              )#
     )#
with( SECCp, interaction.plot(Position, Chamber, Y.trans,#
                              ylab=paste("mean of", Y.use)#
                              )#
     )#
with( SECCp, interaction.plot(Position, Frag, Y.trans,#
                              ylab=paste("mean of ", Y.use)#
                              )#
     )#
#
##________________________________________________#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
# Chamber x Pos Interaction#
lsd <- LSD( Yp.aov$Within, Yp.model, data=SECCp, alpha=0.05, mode="pairwise" )  # compute LSDs based on a 5% error rate (alpha), 2-tailed.  Manual, due to unbalanced data (this is an estimate).#
lsd.CxP <- lsd["Chamber:Position"]#
lsd.FxP <- lsd["Frag:Position"]#
lsd.CxFxP <- lsd["Chamber:Frag:Position"]#
#
##================================================#
## Regional analyses#
# names(Ymc.aov)#
summary(Ymc.aov)        # summary statistics#
model.tables(Ymc.aov, "means")  # effect sizes#
# Interaction Plots#
par(mfrow=c(1,1))   # panel of figures: 1 rows & 1 columns#
with( SECCmc, interaction.plot( Frag, Chamber, Y.trans,#
                               ylab=paste("mean of ", Y.use)#
                               )#
     )#
#
##________________________________________________#
## Planned Multiple Comparisons using Least Significant Differences (LSD) -> comparison intervals for graphical display.#
lsd.mc <- LSD( Ymc.aov$"Block:Chamber:Frag", Ymc.model, data=SECCmc, alpha=0.05, mode="pairwise" )   # compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.mc.FxC <- lsd.mc["Chamber:Frag"]#
lsd.mc <- LSD( Ymc.aov$"Block:Chamber", Ymc.model, data=SECCmc, alpha=0.05, mode="pairwise" )    # compute LSDs based on a 5% error rate (alpha), 2-tailed.#
lsd.mc.C <- lsd.mc["Chamber"]#
#
#
###################################################
## FINAL GRAPHICS#
###################################################
Chamber.map <- data.frame( label = levels(SECCp$Chamber),#
                          col = c("#000000", "#000099", "#990000"),#
                          bg  = c("#FFFFFF", "#FFFFFF", "#FFFFFF"),#
                          pch = c(21, 23, 18),#
                          lty = c(3, 2, 1)#
                          )#
	## Ambient = black, open circles with dotted line ; #
	## Partial = blue, open diamonds with dashed line ; #
	## Full	  = red, solid diamond with solid line.#
Frag.map    <- data.frame( label = levels(SECCp$Frag),#
                          col = c("#000000", "#666666", "#000099", "#990000"), #
                          bg  = c("#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"), #
                          pch = c(19, 15, 22, 21),#
                          lty = c(1, 2, 3, 3)#
                          )#
	## Continuous         = black, filled circles with solid line ; #
	## Full Corridors     =  grey, filled squares with dashed line ; #
	## Pseudo-Corridors	  = blue, open squares with dotted line.#
	## Isolated	          =  red, open circles with dotted line.#
#
## Patch results: Chamber x Position#
plot.means <- with( SECCp, #
                   aggregate( cbind( Y.trans ), #
                             list(Pos = Position, Chamber = Chamber), #
                             mean #
                             ) #
                   )#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
  ## using custom plotMeans function, with custom error bars (LSD)#
  plot.error <- matrix( as.numeric(lsd.CxP/2),#
                       nrow = length(levels(Pos)),#
                       ncol = length(levels(Chamber))#
                       )#
  plotMeans( Y.trans , Pos , Chamber, #
            error.bars = "custom", level = plot.error, cex = 2, lwd = 2,#
            lty = Chamber.map$lty, pch = Chamber.map$pch,#
            col = as.character(Chamber.map$col),#
            bg  = as.character(Chamber.map$bg),#
            main = "Patch means ± 95% LSD",#
            sub  = "95% comparison intervals (LSD)",#
            xlab = attr(SECC, "labels")[["Pos"]],#
            ylab = Y.units#
            )	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## Patch results: Frag x Position (significant in t4)#
plot.means <- with( SECCp, #
                   aggregate( cbind( Y.trans ), #
                             list(Pos = Position, Frag = Frag), #
                             mean #
                             ) #
                   )#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
  ## using custom plotMeans function, with custom error bars (LSD)#
  plot.error <- matrix( as.numeric(lsd.FxP/2),#
                       nrow = length(levels(Pos)),#
                       ncol = length(levels(Frag))#
                       )#
  plotMeans( Y.trans , Pos , Frag, #
            error.bars = "custom", level = plot.error, cex = 2, lwd = 2,#
            lty = Frag.map$lty, pch = Frag.map$pch,#
            col = as.character(Frag.map$col),#
            bg  = as.character(Frag.map$bg),#
            main = "Patch means ± 95% LSD",#
            sub  = "95% comparison intervals (LSD)",#
            xlab = attr(SECC, "labels")[["Pos"]],#
            ylab = Y.units#
            )	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
#
##================================================#
## META-COMMUNITY results#
plot.means <- with( SECCmc, #
                   aggregate( cbind( Y.trans ), #
                             list(Frag=Frag, Chamber=Chamber), #
                             mean #
                             ) #
                   )#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
  ## using custom plotMeans function, with custom error bars (LSD)#
  plot.error <- matrix( as.numeric(lsd.mc.FxC/2),#
                       nrow = length(levels(Frag)),#
                       ncol = length(levels(Chamber))#
                       )#
  plotMeans( Y.trans , Frag , Chamber, #
            error.bars="custom", level=plot.error, cex=2, lwd=2,#
            lty=Chamber.map$lty, pch=Chamber.map$pch,#
            col=as.character(Chamber.map$col),#
            bg=as.character(Chamber.map$bg),#
            main = "Meta-Community means ± 95% LSD",#
            sub  = "95% comparison intervals (LSD)",#
            xlab = attr(SECC, "labels")[["Frag"]],#
            ylab = Y.units#
            )	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})#
#
## Chamber Main Effects#
plot.means <- with( SECCmc, #
                   aggregate( cbind( Y.trans ), #
                             list(Chamber=Chamber), #
                             mean #
                             ) #
                   )#
plot.error <- rep( as.numeric(lsd.mc.C/2), length(levels(plot.means$Chamber)) )#
par( mfrow=c(1,1), lty=1, cex=1, lwd=1 )#
with( plot.means, {#
  ## using custom plotMeans function, with custom error bars (LSD)#
  plotMeans( Y.trans , Chamber, #
            error.bars="custom", level=plot.error, cex=2, lwd=2,#
            lty=Chamber.map$lty[3], pch=Chamber.map$pch,#
            col=as.character(Chamber.map$col),#
            bg=as.character(Chamber.map$bg),#
            main = "Meta-Community means ± 95% LSD",#
            sub  = "95% comparison intervals (LSD)",#
            xlab = attr(SECC, "labels")[["Chamber"]],#
            ylab = Y.units#
            )	# as.character() is needed for string arguments (color hex strings), but I'm still not entirely sure why.  If it is not used, that argument is essentially ignored, and (ugly) defaults are used instead.#
})
?sink
pdf( file = "~/Desktop/test.pdf" )#
#
print("Hello")#
#
dev.off()
?print
?plot.new
pdf( file = "~/Desktop/test.pdf" )#
txt <- "Hello"#
plot.new()#
text(txt)#
plot( rep(1, 25), 1:25, pch = 1:25 )#
#
dev.off()
rep(1, 25)
?mtext
pdf( file = "~/Desktop/test.pdf" )#
txt <- "Hello"#
#
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt)#
plot( rep(1, 25), 1:25, pch = 1:25 )#
#
dev.off()
txt <- "Hello World"#
#
pdf( file = "~/Desktop/test.pdf" )#
#
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0)#
plot( rep(1, 25), 1:25, pch = 1:25 )#
#
dev.off()
?plot.text
?text
?text_to_plot
par("font")
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, outer = TRUE)#
plot( rep(1, 25), 1:25, pch = 1:25 )
txt <- "Hello World"
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, outer = TRUE)#
plot( rep(1, 25), 1:25, pch = 1:25 )
par( mfrow=c(1,1) )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, outer = TRUE)#
plot( rep(1, 25), 1:25, pch = 1:25 )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0)#
plot( rep(1, 25), 1:25, pch = 1:25 )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, font = 10)
mtext(txt, adj = 0, side = 3, line = 0, font = "Courier" )
mtext(txt, adj = 0, side = 3, line = 0, family = "Courier" )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, family = "Courier" )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, font = 0.5, family = "Courier" )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, font = 0.5, family = "Courier", cex = 0.5, col = "black")
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, font = 0.5, family = "Courier", cex = 0.8, col = "black")
par("cex")
?cex
?par
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, font = 0.5, family = "mono", cex = 0.8, col = "black")
?mtext
txt <- "Hello World\n123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890"
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, font = 0.5, family = "mono", cex = 0.8, col = "black")
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, family = "mono", cex = 1, col = "black")
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, family = "Menlo", cex = 1, col = "black")
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext(txt, adj = 0, side = 3, line = 0, family = "mono", cex = 1, col = "black")
?sink
?paste
txt <- "Hello World ±\n123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890"
plot.new()
mtext(txt, adj = 0, side = 3, line = 0, family = "mono", cex = 1, col = "black")
?plotmath
?bquote
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( cat(txt, fill = TRUE, width = 56), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( paste(txt, fill = TRUE, width = 56), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( bquote(%=-%), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( bquote(%+-%), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )#
plot( rep(1, 25), 1:25, pch = 1:25 )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( bquote(%+-%), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( bquote(x %+-% y), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( bquote("foo" %+-% "bar"), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( paste(txt, fill = TRUE, width = 56), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
?paste
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( format(txt, width = 56), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
format(txt, width = 56)
format(txt, width = 24)
toString(txt, width = 24)
plot.new()#
# plot.window(c(0, 100), c(0, 100))#
mtext( paste(txt, width = 24), #
       adj = 0, side = 3, line = 0, #
       family = "mono", cex = 1, col = "black"#
      )
is.null(crap)
?plotmath
