#eOptima<-matrix(eOptimum,numCom,1) #this isn't working properly
#initial conditions
N[,]<-10 #I think this is equivalent to what Jon wrote N(:,:) - Initial Species Abundances
N0<-N
Nt<-N
envt0<-seq(0,eAMP, 1/(numCom-1)) #Initial environmental states for asynchronous environmental fluctuations between patches/communities - I flipped this around as well
envt<-envt0
res0<-matrix(0,numCom,1)
res0[,]<-10 #initial resource abundance
res<-res0
Rt<-res
initM<-cbind(envt0,res0,N0)
NdataM<-initM
init<-c(envt0,res0,N0) #monster vector of initial conditions
Ndata<-init
#initialize environment asynchronously (different phase) between 0 and 1 within sin wave
#make mod function
mod<-function(x,m)
{
  t1<-floor(x/m)
  return(x-t1*m)
}
envtini<-matrix(0,1,numCom)
for(j in 1:numCom)
    if(mod(j,2)==0) # half the communities have environments going in opposite directions to enable asynchrony over entire period, instead of only half the sin wave.
        {envtini[j] <- pi - asin((2*(eOptimum[j]/eAMP)) -1)
        } else{envtini[j] <- asin((2*(eOptimum[j]/eAMP)) -1)
        }
consume<-matrix(0,numCom,numSp)
migrants<-matrix(0,numCom,numSp)
#ODE System - no idea what this is - ask Jon
for(t in 1:Tmax){
  for(i in 1:numSp){
    migrants[,i]<-sum(N[,i]) #important to do this BEFORE updating dynamics, otherwise values will update in an inappropriate order
    for(j in 1:numCom){
      migrants[j,i]<-migrants[j,i] - N[j,i] #important to do this BEFORE updating dynamics, otherwise values will update in an inappropriate order
      }
      #model - not sure if part after extinction Threshold should be in this loop
      for(j in 1:numCom){
        envt[j]<-((sin(envtini[j] + 2*pi*t/ePeriod)+1)/2)*eAMP #Environmental state at current timestep [* Amplitude]
        for(i in 1:numSp){
          consume[j,i]<-(1.5 - abs(eOptimum[i] - envt[j]))/10
          Nt[j,i] <- N[j,i] +( (eff*consume[j,i]*res[j] - mort)*N[j,i] + disp*( migrants[j,i]/(numCom-1) ) - disp*N[j,i] ) *DT # Consumers + dispersal
          }
          Rt[j] = res[j] + (rInput - rLoss*res[j] - res[j] * (sum(consume[j,]*N[j,]) ) )*DT # Resources
      }
      Nextinct<- Nt>Ext #Extinction threshold
      N<-Nt*Nextinct;   # set N to new value - multiply each item in the matrix by either 1 (not extinct) or 0(extinct)
      res<- Rt # set res to new value
      #Com1<-matrix(NA, nrow=Tmax, ncol=numSp)
      #Com1[t,]<-N[,1] #attempt to get community 1 to print out - one row for each time step
      #DataRow<-c(envt,res,N)
      #Ndata[t,]<-DataRow #Store Output for this timestep
}
plot(Com1[,1]~Tdata)
N
str(Com)
ls()
str(Nt)
str(Tdata)
str(Ndata)
N[,]<-10 #I think this is equivalent to what Jon wrote N(:,:) - Initial Species Abundances
N
N[,1}
N[,]
N[,1]
source("/tmp/r-plugin-jaw/Rsource-34856-SIH2.0.R")
ls()
str(N)
N
source("/tmp/r-plugin-jaw/Rsource-34856-SIH2.0.R")
plot(Com1[,1]~Tdata, type='line')
plot(Com1[,1]~Tdata, type='l')
getwd()  # Check that we're in the right place
?seq
source("/tmp/r-plugin-jaw/Rsource-49287-SIH2.02.R")
par(mfrow=c(3,1))#
#
plot(Com1[,1]~Tdata, type='l', ylim=c(0,100), main=disp)#
for(i in 2:numSp){#
  lines(Com1[,i]~Tdata, col=i)#
  }#
  #
plot(Env1[,1]~Tdata, type='l', main="Environment")#
#for(i in 2:numSp){#
    #lines(Env1[,i]~Tdata, col=i)#
    #}#
#
plot(consume1[,1]~Tdata, type='l', main="consume")
str(Com1)
> plot(Com1[,]~Tdata, type='l', ylim=c(0,100), main=disp)
 plot(Com1[,]~Tdata, type='l', ylim=c(0,100), main=disp)
 plot(Com1, type='l', ylim=c(0,100), main=disp)
 plot( Tdata, Com1, type='l', ylim=c(0,100), main=disp)
?xy.plot
?plot.xy
?plot.ts
?plot
?plotmap
??plotmap
  getwd()  # Check that we're in the right place
  setwd("./ SECC/")  # relative to my usual default wd in R GUI (Mac).
source("/tmp/r-plugin-jaw/Rsource-24114-ARA~cyanobacteria.R")
traceback()
source("/tmp/r-plugin-jaw/Rsource-24114-ARA~cyanobacteria.R")
?densityplot
library(lattice)
source("/tmp/r-plugin-jaw/Rsource-24114-ARA~cyanobacteria.R")
SECCstr(SECC.use)
SECCstr(SECCp)
nrow(SECCp)
nrow(SECC.use)
str(SECCp)
SECCp  <- if (TRUE)  SECC_aggregate( SECC.use, trt = 'Position' )  else SECC.use
SECCstr(SECCp)
str(SECCp)
str(SECC.use)
str(SECC)
nrow(SECC.use)
nrow(SECCp)
unique(SECC.use$Chamber)
unique(SECC.use$Frag)
unique(SECC.use$Position)
unique(SECC.use$Block)
unique(SECC.use$Time)
source("/tmp/r-plugin-jaw/Rsource-24114-SECC.functions.R")
source('./lib/init.R')
library(lattice)
X.col <- 'Cells.m'   # Column to analyze as explanatory variable        *****
Y.col <- 'ARA.m'     # Column to analyze as response variable           *****
vars.ls   <- c("ARA.m", "Cells.m", "Hcells.m")  # for data exploration?
Time.use     <- levels(SECC$Time)[1]      # Time (index: 1-3) to include in this run
Chamber.use  <- levels(SECC$Chamber)[c(1, 3)]      # Chamber treatments to include
Frag.use     <- levels(SECC$Frag)         # Frag treatments to include
Position.use <- levels(SECC$Position)[c(1, 3)]     # Patch Positions to include
Save.results  <- FALSE
SECC.prime <- SECC    # save a copy of the original for reference.
sampleA  <- 6   # sample Area, in cm^2:  pi * (2.75/2)^2 ; pi * (2.8 / 2)^2
sample.to.m2 <- (100*100)/sampleA   # scale sample area, in cm^2 to m^2
sample_ml    <- 50  # 50 ml sample
ARA.m2   <- sampleA/(100*100)  # ARA sample area,   in (cm^2 to) m^2
patchA   <- pi * (12.5^2)      # patch area
patch.m2 <- patchA/(100*100)   # patch sample area, in (cm^2 to) m^2
Nfix.ARA.ratio <- 1/3  # ratio of N-fixation : ARA.
SECC <- within( SECC, {
  ARA.ml[ARA.ml < 0] <- 0
  ARA.m[ ARA.m  < 0] <- 0
  ARA.g[ ARA.g  < 0] <- 0
  Nfix <- ARA.m * Nfix.ARA.ratio
})
X.label <- attr(SECC, "labels")[[X.col]]  # explanatory variable label
X.units <- attr(SECC, "units" )[[X.col]]  # explanatory variable units
Y.label <- attr(SECC, "labels")[[Y.col]]  # response variable label
Y.units <- attr(SECC, "units" )[[Y.col]]  # response variable units
X.plotlab <- bquote( .(X.label) * "  " * .(X.units) *  "" )
Y.plotlab <- bquote( .(Y.label) * "  " * .(Y.units) *  "" )
labels.ls <- c()
for(i in 1:length(vars.ls) ){
  var <- vars.ls[i]
  labels.ls[i] <- attr(SECC, "labels")[[var]]
}
Save.filename <- paste("Results - ", Y.col, "~" , X.col, " - ",
                       paste(which(levels(SECC$Time) == Time.use), collapse=""),
                       sep = ""
                   )
Save.text  <- paste("./output/", Save.filename, ".txt", sep = "")
Save.plots <- paste("./graphs/", Save.filename, ".pdf", sep = "")
Save.final <- Save.plots              # Destination for final plots.
Save.divider <-        "================================================================\n"
Save.header  <- paste( "GLM Results for:", Y.label, "(", Y.col, ")",
                     "\n               ~", X.label, "(", X.col, ")",
                     "\nExpt. Time:   ", paste(Time.use,     collapse = ", "),
                     "\nChamber:      ", paste(Chamber.use,  collapse = ", "),
                     "\nFragmentation:", paste(Frag.use,     collapse = ", "),
                     "\nPatches:      ", paste(Position.use, collapse = ", "),
                     paste("\n\n", date(), "\n\n", Save.divider, sep = "")
                     )
Save.end      <- paste("\n",
					   "<============================= END ============================>",
						sep = "\n"
					  )
SECC.use <- SECCclean(SECC, Time.use, Chamber.use, Frag.use, Position.use)
SECCp  <- if (TRUE)  SECC_aggregate( SECC.use, trt = 'Position' )  else SECC.use
SECCmc <- SECC_aggregate( SECC.use, trt = 'Frag' )
SECC.scale  <- "patch"  # c("patch", "mc")
SECCa <- if(SECC.scale == "patch") SECCp else if (SECC.scale == "mc") SECCmc else SECC
SECCa <- within( SECCa, {
                X <- as.numeric( get(X.col) )
                Y <- as.numeric( get(Y.col) )
                Y.use <- Y  # compatibility with older code
})
str(SECCa)
SECCp  <- if (FALSE)  SECC_aggregate( SECC.use, trt = 'Position' )  else SECC.use
SECCmc <- SECC_aggregate( SECC.use, trt = 'Frag' )
SECC.scale  <- "patch"  # c("patch", "mc")
SECCa <- if(SECC.scale == "patch") SECCp else if (SECC.scale == "mc") SECCmc else SECC
SECCa <- within( SECCa, {
                X <- as.numeric( get(X.col) )
                Y <- as.numeric( get(Y.col) )
                Y.use <- Y  # compatibility with older code
})
str(SECCa)
source("/tmp/r-plugin-jaw/Rsource-24114-ARA~cyanobacteria.R")
rm(list=ls())  # clear memory
  getwd()           # Check that we're in the right place
source("./lib/load.R")  # (re-)load data
SECC.prime <- SECC    # save a copy of the original for reference.
source("ARA.R")             # Acetylene Reduction Assay (N-fixation) Analysis
debug(plotMeans)
source("/tmp/r-plugin-jaw/Rsource-42047-SECC-nestedANOVA.R")
plot.means <- with( SECCp,
                   aggregate( cbind( Y.trans ),
                             list(Position = Position, Chamber = Chamber),
                             mean
                             )
                   )
with( plot.means, {
  plot.error <- matrix( as.numeric(msd["Chamber:Position"]/2),
                       nrow = length(levels(Chamber)),
                       ncol = length(levels(Position))
                       )
  plotMeans( Y.trans, Chamber, Position,
            error.bars = "conf.int", level = 0.95, cex = 2, lwd = 2,
            lty = Position.map$lty, pch = Position.map$pch,
            col = as.character(Position.map$col),
            bg  = as.character(Position.map$bg),
            main = Plot.Title,
            sub  = Sub.msd,
            xlab = attr(SECC, "labels")[["Chamber"]],
            ylab = Y.plotlab
            )
})
n
n
n
n
n
n
n
n
n
n
error.bars
n
n
n
n
n
n
n
n
means
sds
ns
Q
source("/tmp/r-plugin-jaw/Rsource-42047-SECC-nestedANOVA.R")
c
source("/tmp/r-plugin-jaw/Rsource-42047-SECC-nestedANOVA.R")
c
source("/tmp/r-plugin-jaw/Rsource-42047-SECC-nestedANOVA.R")
c
undebug(plotMeans)
