#####################################################
## INITIALISE#
#####################################################
rm(list=ls())	# clear memory#
# I usually just use a default working directory on each computer, but this can speed up the process, for projects with files in a different directory:#
# setwd( file.choose() )	# Set Working Directory: #
	# replace file.choose() with a path in quotes "".#
	# file.choose() opens a file browser: can't choose a folder per se, but maybe it won't mind if a file is specified?#
getwd()	# check that we're in the right place.#
#
## LOAD PACKAGES#
library(car)	# load external package 'car', for recode()#
# help(package = car)	#library(help = car)	# get more info about a package, such as who wrote it, what functions are included, and what they do.#
library(reshape)	# sort_df (sort data frame) wrapper for order#
#
#
#####################################################
## GENERATE DATA FRAME COLUMNS#
#####################################################
#
Block.lvls   <- as.integer( seq(1, 8) )#
Time.pt.lvls <- as.integer( seq(1, 4) )#
Chamber.lvls <- c("A", "B", "C")#
Frag.lvls    <- as.integer( seq(1, 4) )#
pos.all.lvls <- c("I", "S", "W", "E", "N", "O")#
pos.order    <- c("I", "O", "S/N", "W/E")	# this order is alphabetical.  Do not change.#
pos.lvls     <- c("I", "S/N", "W/E", "O")	# this order is alphabetical.  Do not change.#
pos.labels   <- c("Inner", "Other", "Outer")#
pos.precip   <- c("Wet", "Mesic", "Dry")#
#
SECC.grid <- expand.grid( Block=Block.lvls, Time.pt=Time.pt.lvls, Chamber=Chamber.lvls, Frag=Frag.lvls, pos=pos.order, KEEP.OUT.ATTRS = FALSE )#
#
SECC.sorted <- sort_df( SECC.grid )#
#
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels= pos.lvls),#
  stringsAsFactors = FALSE#
)  )#
# SECC.base <- within( SECC.base, SampleID <- as.character(SampleID) )	# convert factor to character#
#
# at this point, the basic structure is ready,#
# but it does not yet contain the actual values for position (pos):#
# Inner, Outer, either North or South, either East or West#
# These must be imported from the metadata for the experimental design.
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?
#####################################################
## LOAD METADATA & PATCH IDs#
#####################################################
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
str(PatchIDs)#
head(PatchIDs)
sort(SECC.base$pos)
?sort_df
?order
SECC.grid <- expand.grid( #
                          pos=pos.order, #
                          Frag=Frag.lvls, #
                          Chamber=Chamber.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Block=Block.lvls, #
                          KEEP.OUT.ATTRS = FALSE #
                        )
SECC.sorted <- SECC.grid
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels= pos.lvls),#
  stringsAsFactors = FALSE#
)  )
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?
pos.order    <- c("O", "I", "S/N", "W/E")	# S/N is for alphabetical sorting.  Do not change.
SECC.grid <- expand.grid( #
                          pos=pos.order, #
                          Frag=Frag.lvls, #
                          Chamber=Chamber.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Block=Block.lvls, #
                          KEEP.OUT.ATTRS = FALSE #
                        )
head(SECC.grid)
SECC.sorted <- SECC.grid
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels= pos.lvls),#
  stringsAsFactors = FALSE#
)  )
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
str(PatchIDs)#
head(PatchIDs)
  rm(list=c("block", "time.point", "Warming", "Fragmentation", "position"))
PatchIDs <- within( PatchIDs,#
  Block <- block#
  Time.pt <- time.point#
  Chamber <- Warming#
  Frag <- Fragmentation#
  pos <- position#
  rm(list=c("block", "time.point", "Warming", "Fragmentation", "position"))#
)
PatchIDs <- within( PatchIDs, {#
  Block <- block#
  Time.pt <- time.point#
  Chamber <- Warming#
  Frag <- Fragmentation#
  pos <- position#
  rm(list=c("block", "time.point", "Warming", "Fragmentation", "position"))#
})
str(PatchIDs)
head(PatchIDs)
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- within( PatchIDs, {#
  pos <- position#
  Frag <- Fragmentation#
  Chamber <- Warming#
  Time.pt <- time.point#
  Block <- block#
  rm( list=c("block", "time.point", "Warming", "Fragmentation", "position") )#
})
str(PatchIDs)
?recode
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- within( PatchIDs, {#
#  pos <- position#
  Frag <- Fragmentation#
  Chamber <- Warming#
  Time.pt <- time.point#
  Block <- block#
  rm( list=c("block", "time.point", "Warming", "Fragmentation" ) )#
})#
#
str(PatchIDs)#
head(PatchIDs)
PatchIDs[c("Block", "Time.pt", "Chamber", "Frag", "position")]
PatchIDs <- with( PatchIDs, { data.frame(#
  position = position#
  Frag     = Fragmentation#
  Chamber  = Warming#
  Time.pt  = time.point#
  Block    = block#
)})#
#
str(PatchIDs)#
head(PatchIDs)
PatchIDs <- with( PatchIDs, { data.frame(#
  Block    = block#
  Time.pt  = time.point#
  Chamber  = Warming#
  Frag     = Fragmentation#
  position = position#
)})
PatchIDs <- with( PatchIDs, { data.frame(#
  Block    = block,#
  Time.pt  = time.point,#
  Chamber  = Warming,#
  Frag     = Fragmentation,#
  position = position#
)})
PatchIDs <- with( PatchIDs, data.frame(#
  Block    = block,#
  Time.pt  = time.point,#
  Chamber  = Warming,#
  Frag     = Fragmentation,#
  position = position#
) )
str(PatchIDs)
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  Block    = block,#
  Time.pt  = time.point,#
  Chamber  = Warming,#
  Frag     = Fragmentation,#
  position = position#
) )
str(PatchIDs)
head(PatchIDs)
SECC.merged <- merge(SECC.base, PatchIDs)
str(SECC.merged)
head(SECC.merged)
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = PatchID#
  Block    = block,#
  Time.pt  = time.point,#
  Chamber  = Warming,#
  Frag     = Fragmentation,#
  position = position#
) )#
#
str(PatchIDs)
SECC.merged <- merge(SECC.base, PatchIDs)
str(SECC.merged)
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID)#
  Block    = block,#
  Time.pt  = time.point,#
  Chamber  = Warming,#
  Frag     = Fragmentation,#
  position = position#
) )
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = block,#
  Time.pt  = time.point,#
  Chamber  = Warming,#
  Frag     = Fragmentation,#
  position = position#
) )
str(PatchIDs)
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position)#
) )
str(PatchIDs)
SECC.merged <- merge(SECC.base, PatchIDs)
str(SECC.merged)
head(SECC.merged)
invisible(edit(SECC.merged))
?differences
?compare
?comparison
??Comparison
all.equal(SECC.base$pos, PatchIDs$position)
all.equal(SECC.base$SampleID, PatchIDs$PatchID)
str(PatchIDs)
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position),#
  stringsAsFactors = FALSE#
) )
str(PatchIDs)
all.equal(SECC.base$SampleID, PatchIDs$PatchID)
names(SECC.base)
SECC.base[-"pos"]
SECC.base[,-"pos"]
SECC.base[-c("pos")]
??Indexing
?"[[]]"
?"[["
SECC.base["pos"]
SECC.base[-"pos"]
SECC.base[,-"pos"]
SECC.base[,"pos"]
SECC.base[!"pos"]
SECC.base[!="pos"]
SECC.base[colnames(SECC.base)!="pos"]
SECC.merged <- merge(SECC.base[colnames(SECC.base)!="pos"], PatchIDs)#
str(SECC.merged)
head(SECC.merged)
SECC.merged <- merge(SECC.base[colnames(SECC.base)!=c("SampleID","pos")], PatchIDs)#
str(SECC.merged)
head(SECC.merged)
?merge
intersect( names(SECC.base), names(PatchIDs) )
SECC.merged <- merge(#
  SECC.base[colnames(SECC.base)!=c("SampleID","pos")], #
  PatchIDs[colnames(PatchIDs)!=c("PatchID")], #
  sort=FALSE #
)
str(SECC.merged)
head(SECC.merged)
head(PatchIDs)
str(PatchIDs)
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?
all.equal(SECC.base, PatchIDs)
SECC.base$Block == PatchIDs$Block
sum(SECC.base$Block == PatchIDs$Block)
sum(#
  SECC.base$Block == PatchIDs$Block |#
  SECC.base$Time.pt == PatchIDs$Time.pt |#
  SECC.base$Chamber == PatchIDs$Chamber |#
  SECC.base$Frag == PatchIDs$Frag |#
)	# rows where columns are mismatched.
sum(#
  SECC.base$Block == PatchIDs$Block |#
  SECC.base$Time.pt == PatchIDs$Time.pt |#
  SECC.base$Chamber == PatchIDs$Chamber |#
  SECC.base$Frag == PatchIDs$Frag#
)	# rows where columns are mismatched.
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?
str(PatchIDs)
head(PatchIDs)
SECC.base$Block == PatchIDs$Block
SECC.base[50, ]
PatchIDs[50, ]
sum(#
  SECC.base$Block == PatchIDs$Block |#
  SECC.base$Time.pt == PatchIDs$Time.pt |#
  SECC.base$Chamber == PatchIDs$Chamber |#
  SECC.base$Frag == PatchIDs$Frag#
)	# rows where columns are mismatched.
SECC.base$Time.pt == PatchIDs$Time.pt
SECC.base$Chamber == PatchIDs$Chamber
sum(#
  SECC.base$Block != PatchIDs$Block |#
  SECC.base$Time.pt != PatchIDs$Time.pt |#
  SECC.base$Chamber != PatchIDs$Chamber |#
  SECC.base$Frag != PatchIDs$Frag#
)	# rows where columns are mismatched.
# generate all combinations, cycling through faster, then slower columns.#
SECC.grid <- expand.grid( #
                          pos=pos.order, #
                          Frag=Frag.lvls, #
                          Chamber=Chamber.lvls, #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          KEEP.OUT.ATTRS = FALSE #
                        )#
#
SECC.sorted <- SECC.grid#
# SECC.sorted <- sort_df( SECC.grid ) #
  # useful for wholesale sorting, but I really want the position column in a particular, non-alphabetical order.  #
  # The columns will be re-ordered in the next step anyway.#
#
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels= pos.lvls),#
  stringsAsFactors = FALSE#
)  )#
# SECC.base <- within( SECC.base, SampleID <- as.character(SampleID) )	# convert factor to character#
#
# at this point, the basic structure is ready,#
# but it does not yet contain the actual values for position (pos):#
# Inner, Outer, either North or South, either East or West#
# These must be imported from the metadata for the experimental design.#
#
#
##==================================================#
## CHECK DATA#
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?
sum(#
  SECC.base$Block != PatchIDs$Block |#
  SECC.base$Time.pt != PatchIDs$Time.pt |#
  SECC.base$Chamber != PatchIDs$Chamber |#
  SECC.base$Frag != PatchIDs$Frag#
)	# rows where columns are mismatched.
SECC.merged <- merge(#
  SECC.base[colnames(SECC.base)!=c("SampleID","pos")], #
  PatchIDs[colnames(PatchIDs)!=c("PatchID")], #
  sort=FALSE #
)#
str(SECC.merged)
SECC.base[colnames(SECC.base)!=c("SampleID","pos")]
PatchIDs[colnames(PatchIDs)!=c("PatchID")]
SECC.merged <- merge(#
  SECC.base[colnames(SECC.base)!=c("SampleID","pos")], #
  PatchIDs[colnames(PatchIDs)!=c("PatchID")], #
  sort=FALSE#
)#
str(SECC.merged)
if (rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base,#
    pos <- factor(PatchIDs$position, levels = pos.all.lvls)#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  )#
} else stop("Rows do not match.  Check row sorting before trying to merge.")
if (rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(PatchIDs$position, levels = pos.all.lvls)#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  })#
} else stop("Rows do not match.  Check row sorting before trying to merge.")
if (rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(PatchIDs$position, levels = pos.all.lvls)#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not match.  Check row sorting before trying to merge.")
rows_mismatched <- sum(#
  SECC.base$Block != PatchIDs$Block |#
  SECC.base$Time.pt != PatchIDs$Time.pt |#
  SECC.base$Chamber != PatchIDs$Chamber |#
  SECC.base$Frag != PatchIDs$Frag#
)	# rows where columns are mismatched.  Should be 0
if (rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(PatchIDs$position, levels = pos.all.lvls)#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not match.  Check row sorting before trying to merge.")
str(SECC.merged)
head(SECC.merged)
all.equal(SECC.base, PatchIDs)
SECC.merged <- merge(#
  SECC.base, #
  PatchIDs, #
  sort=FALSE#
) # replicates each entry by 4??#
str(SECC.merged)
head(SECC.merged)
invisible(edit(SECC.merged))
# all.equal(SECC.base, PatchIDs)#
rows_mismatched <- sum(#
  SECC.base$Block != PatchIDs$Block |#
  SECC.base$Time.pt != PatchIDs$Time.pt |#
  SECC.base$Chamber != PatchIDs$Chamber |#
  SECC.base$Frag != PatchIDs$Frag#
)	# rows where columns are mismatched.  Should be 0#
#
if (rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(PatchIDs$position, levels = pos.all.lvls)#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")
str(SECC.merged)
SECC.merged$SampleID == PatchIDs$PatchID
cat(IDs_mismatched, "IDs did not match!  Check inputs & try again.")
IDs_mismatched <- sum( SECC.merged$SampleID != PatchIDs$PatchID )
cat(IDs_mismatched, "IDs did not match!  Check inputs & try again.")
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs & try again.")
str(SECC.merged)
write.csv( SECC.merged, file="SECC_base.csv" )
write.csv( SECC.merged, file="SECC-base.csv" )
?factor
as.numeric(factor(SECC.grid$pos))
as.numeric(factor(SECC.grid$pos))[SECC.grid$pos]
pos.numeric <- as.numeric(factor(SECC.grid$pos))[SECC.grid$pos]  # why is the last bit needed in square brackets?
pos.numeric <- as.numeric(factor(SECC.grid$pos))
names(pos.numeric)
pos.numeric <- as.numeric(levels(SECC.grid$pos))[SECC.grid$pos]  # why is the last bit needed in square brackets?
pos.numeric
pos.factor <- SECC.grid$pos
class(pos.factor)
pos.numeric <- as.numeric(levels(pos.factor))[pos.factor]  # why is the last bit needed in square brackets?
pos.numeric <- as.numeric(pos.factor)  # why is the last bit needed in square brackets?
pos.numeric
?sort_df
names(SECC.grid)
?order
(ii <- order(x <- c(1,1,3:1,1:4,3), y <- c(9,9:1), z <-c(2,1:9)))
## Sorting data frames:#
dd <- transform(data.frame(x,y,z),#
                z = factor(z, labels=LETTERS[9:1]))#
## Either as above {for factor 'z' : using internal coding}:#
dd[ order(x, -y, z) ,]#
## or along 1st column, ties along 2nd, ... *arbitrary* no.{columns}:#
dd[ do.call(order, dd) ,]
z
dd
SECC.sorted <- sort_df( SECC.grid )
head(SECC.sorted)
SECC.grid <- expand.grid( #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Chamber=Chamber.lvls, #
                          Frag=Frag.lvls, #
                          pos=pos.order, #
                          KEEP.OUT.ATTRS = FALSE #
                        )
str(SECC.grid)
SECC.grid <- expand.grid( #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Chamber=Chamber.lvls, #
                          Frag=Frag.lvls, #
                          pos=pos.order, #
                          KEEP.OUT.ATTRS = FALSE #
                        )#
#
# Converting a factor to a "dummy" variable for sorting,#
# based on raw original numeric values (i.e. the level number, not the text label):  see ?factor#
pos.factor <- SECC.grid$pos#
class(pos.factor)#
pos.numeric <- as.numeric(pos.factor)  # I want to use the raw Numeric Codes for sorting.#
#
SECC.sorted <- SECC.grid#
SECC.sorted <- sort_df( SECC.grid, #
  vars=c("Block", "Time.pt", "Chamber", "Frag", "pos") #
)
str(SECC.sorted)
head(SECC.sorted)
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels = pos.lvls),#
  stringsAsFactors = FALSE#
)  )
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?
?factor
pos.relvl <- factor(pos.factor, levels=pos.all.sort )
pos.all.sort <- c("O", "I", "N", "S", "E", "W") # desired sort order.
pos.relvl <- factor(pos.factor, levels=pos.all.sort )
pos.relvl
SECC.grid$pos
pos.relvl <- factor(pos.factor, levels=pos.lvls )
pos.relvl
pos.factor == pos.relvl
levels(pos.factor) == levels(pos.relvl)
c( c("a", "b"), "c")
?[[
?"[["
c(sort.order, "pos")
sort.order <- c("Block", "Time.pt", "Chamber", "Frag") # not including "pos" or "position"
c(sort.order, "pos")
PatchIDs.sort <- sort_df( PatchIDs, #
  vars=c(sort.order, "position") #
)
str(PatchIDs)
head(PatchIDs)
Rows_mismatched <- sum(#
  SECC.base$Block != PatchIDs$Block |#
  SECC.base$Time.pt != PatchIDs$Time.pt |#
  SECC.base$Chamber != PatchIDs$Chamber |#
  SECC.base$Frag != PatchIDs$Frag#
)	# rows where columns are mismatched.  Should be 0
Rows_mismatched
Rows_mismatched <- sum(#
  SECC.base$Block != PatchIDs.sort$Block |#
  SECC.base$Time.pt != PatchIDs.sort$Time.pt |#
  SECC.base$Chamber != PatchIDs.sort$Chamber |#
  SECC.base$Frag != PatchIDs.sort$Frag#
)	# rows where columns are mismatched.  Should be 0
Rows_mismatched
Rows_mismatched <- sum(#
  SECC.base$Block   != PatchIDs.sort$Block   |#
  SECC.base$Time.pt != PatchIDs.sort$Time.pt |#
  SECC.base$Chamber != PatchIDs.sort$Chamber |#
  SECC.base$Frag    != PatchIDs.sort$Frag#
)	# rows where columns are mismatched.  Should be 0
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(PatchIDs.sort$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")
levels(Factor) <- c( "level 1", "level 2" )	# rename factor levels: ORDER MATTERS (levels reassigned, not reordered)!  Unspecified factor levels are NOT dropped, and values not specified are not changed.
#####################################################
# Template generator for SECC data#
# With standard columns, all treatment levels and label codes#
# Jonathan Whiteley	2011-01-21#
# R v2.12#
#####################################################
## INITIALISE#
#####################################################
rm(list=ls())	# clear memory#
# I usually just use a default working directory on each computer, but this can speed up the process, for projects with files in a different directory:#
# setwd( file.choose() )	# Set Working Directory: #
	# replace file.choose() with a path in quotes "".#
	# file.choose() opens a file browser: can't choose a folder per se, but maybe it won't mind if a file is specified?#
getwd()	# check that we're in the right place.#
#
## LOAD PACKAGES#
library(car)	# load external package 'car', for recode()#
# help(package = car)	#library(help = car)	# get more info about a package, such as who wrote it, what functions are included, and what they do.#
library(reshape)	# sort_df (sort data frame) wrapper for order#
#
#
#####################################################
## GENERATE DATA FRAME COLUMNS#
#####################################################
#
Block.lvls    <- as.integer( seq(1, 8) )#
Time.pt.lvls  <- as.integer( seq(1, 4) )#
Chamber.lvls  <- c("A", "B", "C")#
Chamber.labels<- c("Ambient", "Partial Chamber", "Full Chamber")#
Chamber.Heat  <- c("Ambient", "Warm", "Hot")#
Frag.lvls     <- as.integer( seq(1, 4) )#
Frag.labels   <- c("Contiguous", "Full Corridors", "Pseudo-Corridors", "Isolated")#
pos.all.lvls  <- c("I", "S", "W", "E", "N", "O")#
pos.all.sort  <- c("O", "I", "N", "S", "E", "W") # desired sort order.#
pos.lvls      <- c("I", "S/N", "W/E", "O")	# S/N is for alphabetical sorting.  Do not change.#
pos.sort      <- c("O", "I", "S/N", "W/E")	# S/N is for alphabetical sorting.  Do not change.#
pos.labels    <- c("Inner", "Other", "Outer")#
pos.precip    <- c("Wet", "Mesic", "Dry")#
#
sort.order <- c("Time.pt", "Block","Chamber", "Frag") # not including "pos" or "position"#
  # The nesting structure puts "Block" first (largest experimental unit).#
  # I tend to sort by Time.pt first, however.#
#
# generate all combinations, cycling through faster, then slower columns.#
SECC.grid <- expand.grid( #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Chamber=Chamber.lvls, #
                          Frag=Frag.lvls, #
                          pos=pos.sort, #
                          KEEP.OUT.ATTRS = FALSE #
                        )#
#
# SECC.sorted <- SECC.grid#
SECC.sorted <- sort_df( SECC.grid, #
  vars=c(sort.order, "pos") #
) #
  # useful for wholesale sorting, but I really want the position column in a particular, non-alphabetical order (which is used for data entry).  #
  # unless, I can use the factor codes for pos, rather than the levels. ***#
  # The columns will be re-ordered in the next step anyway.#
#
str(SECC.sorted)#
head(SECC.sorted)#
  #
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels = pos.lvls),#
  stringsAsFactors = FALSE#
)  )#
# SECC.base <- within( SECC.base, SampleID <- as.character(SampleID) )	# convert factor to character#
#
# at this point, the basic structure is ready,#
# but it does not yet contain the actual values for position (pos):#
# Inner, Outer, either North or South, either East or West#
# These must be imported from the metadata for the experimental design.#
#
#
##==================================================#
## CHECK DATA#
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?#
# invisible(edit(SECC.base))	# opens spreadsheet and returns changes invisibly.  #
# Use fix() to make permanent changes, or assign the result of edit() to an object.#
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?
#####################################################
## LOAD METADATA & PATCH IDs#
#####################################################
# Load MetaData containing actual (observed) patch positions.#
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position, levels=pos.all.sort),  # levels in sort order#
  stringsAsFactors = FALSE#
) )#
# Sort PatchIDs in the same order as the base template (or make sure it is).#
# This is great in theory, except that I really want patch positions in the order specified in the base template, and I'm not sure how to do this automatically:#
  # O(uter), I(nner), N/S, E/W#
  # This is mostly to facilitate data processing & entry, which typically occurs in this order.#
  # Sorting a data frame actually uses the numeric codes for factors, not the levels.  #
  # So, I just have to re-order the levels to be in the order I want the values to be sorted in.#
PatchIDs.sort <- sort_df( PatchIDs, #
  vars=c(sort.order, "position") #
)#
#
str(PatchIDs.sort)#
head(PatchIDs.sort)
Rows_mismatched <- sum(#
  SECC.base$Block   != PatchIDs.sort$Block   |#
  SECC.base$Time.pt != PatchIDs.sort$Time.pt |#
  SECC.base$Chamber != PatchIDs.sort$Chamber |#
  SECC.base$Frag    != PatchIDs.sort$Frag#
)	# rows where columns are mismatched.  Should be 0#
#
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(PatchIDs.sort$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")#
#
IDs_mismatched <- sum( SECC.merged$SampleID != PatchIDs.sort$PatchID )#
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs (especially sorting) and try again.")
str(SECC.merged)
head(SECC.merged)
str(SECC.merged)
invisible(edit(SECC.merged))
write.csv( SECC.merged, file="SECC-base.csv" )
?cat
Rows_mismatched <- sum(#
  SECC.base$Block   != Positions$Block   |#
  SECC.base$Time.pt != Positions$Time.pt |#
  SECC.base$Chamber != Positions$Chamber |#
  SECC.base$Frag    != Positions$Frag#
)	# rows where columns are mismatched.  Should be 0
#####################################################
## LOAD METADATA & PATCH IDs#
#####################################################
# Load MetaData containing actual (observed) patch positions.#
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position, levels=pos.all.sort),  # levels in sort order#
  stringsAsFactors = FALSE#
) )#
# Sort PatchIDs in the same order as the base template (or make sure it is).#
# This is great in theory, except that I really want patch positions in the order specified in the base template, and I'm not sure how to do this automatically:#
  # O(uter), I(nner), N/S, E/W#
  # This is mostly to facilitate data processing & entry, which typically occurs in this order.#
  # Sorting a data frame actually uses the numeric codes for factors, not the levels.  #
  # So, I just have to re-order the levels to be in the order I want the values to be sorted in.#
Positions <- sort_df( PatchIDs, #
  vars=c(sort.order, "position") #
)#
#
str(Positions)#
head(Positions)
#####################################################
## UPDATE BASE WITH ACTUAL POSITION VALUES (from MetaData)#
#####################################################
#SECC.merged <- merge(#
#  SECC.base, # [colnames(SECC.base)!=c("SampleID","pos")], #
#  Positions, #
#  sort=FALSE#
#) # replicates each entry by 4??#
#
# all.equal(SECC.base, PatchIDs)#
Rows_mismatched <- sum(#
  SECC.base$Block   != Positions$Block   |#
  SECC.base$Time.pt != Positions$Time.pt |#
  SECC.base$Chamber != Positions$Chamber |#
  SECC.base$Frag    != Positions$Frag#
)	# rows where columns are mismatched.  Should be 0#
#
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(Positions$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")#
#
IDs_mismatched <- sum( SECC.merged$SampleID != Positions$PatchID )#
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs (especially sorting) and try again.")#
#
#
## Check Data before export.#
str(SECC.merged)#
head(SECC.merged)#
# invisible(edit(SECC.merged))
#####################################################
# Template generator for SECC data#
# With standard columns, all treatment levels and label codes#
# Jonathan Whiteley	2011-01-21#
# R v2.12#
#####################################################
## INITIALISE#
#####################################################
rm(list=ls())	# clear memory#
# I usually just use a default working directory on each computer, but this can speed up the process, for projects with files in a different directory:#
# setwd( file.choose() )	# Set Working Directory: #
	# replace file.choose() with a path in quotes "".#
	# file.choose() opens a file browser: can't choose a folder per se, but maybe it won't mind if a file is specified?#
getwd()	# check that we're in the right place.#
#
## LOAD PACKAGES#
library(car)	# load external package 'car', for recode()#
# help(package = car)	#library(help = car)	# get more info about a package, such as who wrote it, what functions are included, and what they do.#
library(reshape)	# sort_df (sort data frame) wrapper for order#
#
#
#####################################################
## GENERATE DATA FRAME COLUMNS#
#####################################################
#
Block.lvls    <- as.integer( seq(1, 8) )#
Time.pt.lvls  <- as.integer( seq(1, 4) )#
Chamber.lvls  <- c("A", "B", "C")#
Chamber.labels<- c("Ambient", "Partial Chamber", "Full Chamber")#
Chamber.Heat  <- c("Ambient", "Warm", "Hot")#
Frag.lvls     <- as.integer( seq(1, 4) )#
Frag.labels   <- c("Contiguous", "Full Corridors", "Pseudo-Corridors", "Isolated")#
pos.old.lvls  <- c( 1 , "S", "W", "E", "N",  0 )  # I used to use 0 & 1 for 'Outer' & 'Inner', respectively.#
pos.all.lvls  <- c("I", "S", "W", "E", "N", "O")#
pos.all.sort  <- c("O", "I", "N", "S", "E", "W") # desired sort order.#
pos.lvls      <- c("I", "S/N", "W/E", "O")	# S/N is for alphabetical sorting.  Do not change.#
pos.sort      <- c("O", "I", "S/N", "W/E")	# S/N is for alphabetical sorting.  Do not change.#
pos.labels    <- c("Inner", "Other", "Outer")#
pos.precip    <- c("Wet", "Mesic", "Dry")#
#
sort.order <- c("Time.pt", "Block", "Chamber", "Frag") # not including "pos" or "position"#
  # The nesting structure puts "Block" first (largest experimental unit).#
  # I tend to sort by Time.pt first, however,#
  # To reflect the order in which samples were actually collected & processed.#
#
# Generate all combinations of treatment levels (cycling through faster, then slower columns).#
SECC.grid <- expand.grid( #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Chamber=Chamber.lvls, #
                          Frag=Frag.lvls, #
                          pos=pos.sort, #
                          KEEP.OUT.ATTRS = FALSE #
                        )#
#
# SECC.sorted <- SECC.grid#
SECC.sorted <- sort_df( SECC.grid, #
  vars=c(sort.order, "pos") #
) #
  # useful for wholesale sorting, but I really want the position column in a particular, non-alphabetical order (which is used for data entry).  #
  # unless, I can use the factor codes for pos, rather than the levels. ***#
  # The columns will be re-ordered in the next step anyway.#
#
str(SECC.sorted)#
head(SECC.sorted)#
  #
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels = pos.lvls),#
  stringsAsFactors = FALSE#
)  )#
# SECC.base <- within( SECC.base, SampleID <- as.character(SampleID) )	# convert factor to character#
#
# at this point, the basic structure is ready,#
# but it does not yet contain the actual values for position (pos):#
# Inner, Outer, either North or South, either East or West#
# These must be imported from the metadata for the experimental design.#
#
#
##==================================================#
## CHECK DATA#
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?#
# invisible(edit(SECC.base))	# opens spreadsheet and returns changes invisibly.  #
# Use fix() to make permanent changes, or assign the result of edit() to an object.#
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?#
#
#
#
#####################################################
## LOAD METADATA & PATCH IDs#
#####################################################
# Load MetaData containing actual (observed) patch positions.#
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position, levels=pos.all.sort),  # levels in sort order#
  stringsAsFactors = FALSE#
) )#
# Sort PatchIDs in the same order as the base template (or make sure it is).#
# This is great in theory, except that I really want patch positions in the order specified in the base template, and I'm not sure how to do this automatically:#
  # O(uter), I(nner), N/S, E/W#
  # This is mostly to facilitate data processing & entry, which typically occurs in this order.#
  # Sorting a data frame actually uses the numeric codes for factors, not the levels.  #
  # So, I just have to re-order the levels to be in the order I want the values to be sorted in.#
Positions <- sort_df( PatchIDs, #
  vars=c(sort.order, "position") #
)#
#
str(Positions)#
head(Positions)#
#
#
#####################################################
## UPDATE BASE WITH ACTUAL POSITION VALUES (from MetaData)#
#####################################################
#SECC.merged <- merge(#
#  SECC.base, # [colnames(SECC.base)!=c("SampleID","pos")], #
#  Positions, #
#  sort=FALSE#
#) # replicates each entry by 4??#
#
# all.equal(SECC.base, PatchIDs)#
Rows_mismatched <- sum(#
  SECC.base$Block   != Positions$Block   |#
  SECC.base$Time.pt != Positions$Time.pt |#
  SECC.base$Chamber != Positions$Chamber |#
  SECC.base$Frag    != Positions$Frag#
)	# rows where columns are mismatched.  Should be 0#
#
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(Positions$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")#
#
IDs_mismatched <- sum( SECC.merged$SampleID != Positions$PatchID )#
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs (especially sorting) and try again.")#
#
#
## Check Data before export.#
str(SECC.merged)#
head(SECC.merged)#
# invisible(edit(SECC.merged))#
#
#
#
#####################################################
## EXPORT TO FILE (END)#
#####################################################
#
write.csv( SECC.merged, file="SECC-base.csv" )
library(help = car)
save.ls <- c(#
  'Block.lvls',#
  'Time.pt.lvls',#
  'Chamber.lvls', 'Chamber.labels', 'Chamber.Heat',#
  'Frag.lvls', 'Frag.labels',#
  'pos.old.lvls', 'pos.all.lvls', 'pos.all.sort', #
  'pos.labels', 'pos.precip', #
  'Trt.nest.order', 'Trt.sort.order'#
)
Trt.nest.order <- c("Block", "Time.pt","Chamber", "Frag", "pos")#
Trt.sort.order <- c("Time.pt", "Block", "Chamber", "Frag") # not including "pos" or "position"
#####################################################
# Template generator for SECC data table#
# With standard columns, all treatment levels and label codes#
# Jonathan Whiteley	2011-01-24#
# R v2.12#
#####################################################
## INITIALISE#
#####################################################
rm(list=ls())	# clear memory#
# I usually just use a default working directory on each computer, but this can speed up the process, for projects with files in a different directory:#
# setwd( file.choose() )	# Set Working Directory: #
	# replace file.choose() with a path in quotes "".#
	# file.choose() opens a file browser: can't choose a folder per se, but maybe it won't mind if a file is specified?#
getwd()	# check that we're in the right place.#
#
## LOAD PACKAGES#
# help(package = car)	#library(help = car)	# get more info about a package, such as who wrote it, what functions are included, and what they do.#
library(car)	# load external package 'car', for recode()#
library(reshape)	# sort_df (sort data frame) wrapper for order#
#
#
#####################################################
## GENERATE DATA FRAME COLUMNS#
#####################################################
save.ls <- c(#
  'Block.lvls',#
  'Time.pt.lvls',#
  'Chamber.lvls', 'Chamber.labels', 'Chamber.Heat',#
  'Frag.lvls', 'Frag.labels',#
  'pos.old.lvls', 'pos.all.lvls', 'pos.all.sort', #
  'pos.labels', 'pos.precip', #
  'Trt.nest.order', 'Trt.sort.order'#
)#
#
Block.lvls    <- as.integer( seq(1, 8) )#
Time.pt.lvls  <- as.integer( seq(1, 4) )#
Chamber.lvls  <- c("A", "B", "C")#
Chamber.labels<- c("Ambient", "Partial Chamber", "Full Chamber")#
Chamber.Heat  <- c("Ambient", "Warm", "Hot")#
Frag.lvls     <- as.integer( seq(1, 4) )#
Frag.labels   <- c("Contiguous", "Full Corridors", "Pseudo-Corridors", "Isolated")#
pos.old.lvls  <- c( 1 , "S", "W", "E", "N",  0 )  # I used to use 0 & 1 for 'Outer' & 'Inner', respectively.#
pos.all.lvls  <- c("I", "S", "W", "E", "N", "O")#
pos.all.sort  <- c("O", "I", "N", "S", "E", "W") # desired sort order.#
pos.lvls      <- c("I", "S/N", "W/E", "O")	# S/N is for alphabetical sorting.  Do not change.#
pos.sort      <- c("O", "I", "S/N", "W/E")	# S/N is for alphabetical sorting.  Do not change.#
pos.labels    <- c("Inner", "Other", "Outer")#
pos.precip    <- c("Wet", "Mesic", "Dry")#
#
Trt.nest.order <- c("Block", "Time.pt","Chamber", "Frag", "pos")#
Trt.sort.order <- c("Time.pt", "Block", "Chamber", "Frag") # not including "pos" or "position"#
  # The nesting structure puts "Block" first (largest experimental unit).#
  # I tend to sort by Time.pt first, however,#
  # To reflect the order in which samples were actually collected & processed.#
#
# Generate all combinations of treatment levels (cycling through faster, then slower columns).#
SECC.grid <- expand.grid( #
                          Block=Block.lvls, #
                          Time.pt=Time.pt.lvls, #
                          Chamber=Chamber.lvls, #
                          Frag=Frag.lvls, #
                          pos=pos.sort, #
                          KEEP.OUT.ATTRS = FALSE #
                        )#
#
# SECC.sorted <- SECC.grid#
SECC.sorted <- sort_df( SECC.grid, #
  vars=c(Trt.sort.order, "pos") #
) #
  # useful for wholesale sorting, but I really want the position column in a particular, non-alphabetical order (which is used for data entry).  #
  # unless, I can use the factor codes for pos, rather than the levels. ***#
  # The columns will be re-ordered in the next step anyway.#
#
str(SECC.sorted)#
head(SECC.sorted)#
  #
SECC.base <- with(SECC.sorted, data.frame(#
  SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep=""),#
  Block   = factor(Block),#
  Time.pt = factor(Time.pt),#
  Chamber = factor(Chamber),#
  Frag    = factor(Frag),#
  pos     = factor(pos, levels = pos.lvls),#
  stringsAsFactors = FALSE#
)  )#
# SECC.base <- within( SECC.base, SampleID <- as.character(SampleID) )	# convert factor to character#
#
# at this point, the basic structure is ready,#
# but it does not yet contain the actual values for position (pos):#
# Inner, Outer, either North or South, either East or West#
# These must be imported from the metadata for the experimental design.#
#
#
##==================================================#
## CHECK DATA#
str(SECC.base)		# check structure: are the appropriate columns factors, numeric, etc.?#
# invisible(edit(SECC.base))	# opens spreadsheet and returns changes invisibly.  #
# Use fix() to make permanent changes, or assign the result of edit() to an object.#
head(SECC.base)		# have a peek at the first 6 rows & columns: is this what you expected?#
#
#
#
#####################################################
## LOAD METADATA & PATCH IDs#
#####################################################
# Load MetaData containing actual (observed) patch positions.#
PatchIDs <- read.csv("SECC-PatchIDs.csv")#
PatchIDs <- with( PatchIDs, data.frame(#
  PatchID  = as.character(PatchID),#
  Block    = factor(block),#
  Time.pt  = factor(time.point),#
  Chamber  = factor(Warming),#
  Frag     = factor(Fragmentation),#
  position = factor(position, levels=pos.all.sort),  # levels in sort order#
  stringsAsFactors = FALSE#
) )#
# Sort PatchIDs in the same order as the base template (or make sure it is).#
# This is great in theory, except that I really want patch positions in the order specified in the base template, and I'm not sure how to do this automatically:#
  # O(uter), I(nner), N/S, E/W#
  # This is mostly to facilitate data processing & entry, which typically occurs in this order.#
  # Sorting a data frame actually uses the numeric codes for factors, not the levels.  #
  # So, I just have to re-order the levels to be in the order I want the values to be sorted in.#
Positions <- sort_df( PatchIDs, #
  vars=c(Trt.sort.order, "position") #
)#
#
str(Positions)#
head(Positions)#
#
#
#####################################################
## UPDATE BASE WITH ACTUAL POSITION VALUES (from MetaData)#
#####################################################
#SECC.merged <- merge(#
#  SECC.base, # [colnames(SECC.base)!=c("SampleID","pos")], #
#  Positions, #
#  sort=FALSE#
#) # replicates each entry by 4??#
#
# all.equal(SECC.base, PatchIDs)#
Rows_mismatched <- sum(#
  SECC.base$Block   != Positions$Block   |#
  SECC.base$Time.pt != Positions$Time.pt |#
  SECC.base$Chamber != Positions$Chamber |#
  SECC.base$Frag    != Positions$Frag#
)	# rows where columns are mismatched.  Should be 0#
#
if (Rows_mismatched == 0) {#
  SECC.merged <- within( SECC.base, {#
    pos <- factor(Positions$position, levels = pos.all.lvls)  # levels in desired order.#
    SampleID = paste(Block, Time.pt, Chamber, "-", Frag, ".", pos, sep="")#
  })#
} else stop("Rows do not all match.  Check row sorting before trying to merge.")#
#
IDs_mismatched <- sum( SECC.merged$SampleID != Positions$PatchID )#
if (IDs_mismatched == 0) {#
  cat("All IDs match.  Success!")#
} else cat(IDs_mismatched, "IDs did not match!  Check inputs (especially sorting) and try again.")#
#
#
## Check Data before export.#
str(SECC.merged)#
head(SECC.merged)#
# invisible(edit(SECC.merged))
write.csv( SECC.merged, file="SECC-base.csv" )
save( list=c( SECC.base, save.ls ), file="SECC_factors.R" )
save( list=c( 'SECC.base', save.ls ), file="SECC_factors.R" )
load("/Users/jaw/Documents/ My Documents/ Academic/McGill/PhD/Data/Data Template/Output/SECC_factors.R")
ls()
Frag.labels
getwd()             # check current wd
setwd("./ SECC/")	# Project Directory.
getwd()             # check current wd
load('./save/SECC_factors.R')	# includes SECC.base data.frame
Pos.all.lvls
Pos_all_lvls
Chamber_lvls
Chamber_labels
Pos_lvls
ls()
Pos_labels
Pos_all_lvls %in% Pos_all_sort
Pos_all_lvls == Pos_all_sort
Pos_old_lvls %in% Pos_all_sort
Pos_old_lvls %in% Pos_all_lvls
if ( levels(Pos) %in% Pos_all_lvls) {#
  #
}
if ( levels(SECC.base$Pos) %in% Pos_all_lvls) {#
  #
}
?or
??or
??boolean
ls()
Trt_nest_order
c(NULL, 1)
Data_files <- dir('./data/')#
Data_objects <- NULL#
for (File_name in Data_files) {#
  File_path <- paste("./data/", File_name, sep="")#
  temp <- read.csv(File_path)#
  Object_name <- cleanVarName(File_name)#
  # remove file extension from the object name  #
  Object_name <- gsub("\\.csv\\b", "", Object_name, perl=TRUE ) #
  # assign data to object with similar name as the file.#
  assign(Object_name, temp)#
  # collect a list of object names for further processing.#
  Data_objects <- c(Data_objects, Object_name)#
}#
rm( list=c('File_name', 'File_path','temp','Object_name') )
source("./lib/fun.R")   # define functions
library(car)		# load external package 'car', for recode()
###################################################
## LOAD DATA FILES#
###################################################
load('./save/SECC_factors.R')	# includes SECC.base data.frame, #
  # and other vectors of standard column names and levels.#
SECC.raw <- read.csv("./save/SECC_base.csv") # just to check how it is imported.  #
  # Should be the same values as SECC.base, but raw column types (only character columns are factors).#
#
Data_files <- dir('./data/')#
Data_objects <- NULL#
for (File_name in Data_files) {#
  File_path <- paste("./data/", File_name, sep="")#
  temp <- read.csv(File_path)#
  Object_name <- cleanVarName(File_name)#
  # remove file extension from the object name  #
  Object_name <- gsub("\\.csv\\b", "", Object_name, perl=TRUE ) #
  # assign data to object with similar name as the file.#
  assign(Object_name, temp)#
  # collect a list of object names for further processing.#
  Data_objects <- c(Data_objects, Object_name)#
}#
rm( list=c('File_name', 'File_path','temp','Object_name') )
Data_objects
if ( colnames(SECC.base) %in% ColNames_std ) {#
  #
}
ColNames_std <- Trt_nest_order
if ( colnames(SECC.base) %in% ColNames_std ) {#
  #
}
help.start()
min(c(TRUE, FALSE, FALSE, TRUE))
max(c(TRUE, FALSE, FALSE, TRUE))
min(c(TRUE, TRUE))
Trt_nest_order
if (  min( colnames(SECC.base) %in% ColNames_std ) == 0 ) {#
  # min(boolean_vector) == 0 means there was at least on FALSE result#
  # check for most likely non-standard names#
  # rename if possible#
  # if it still fails, throw an Error message: this file needs Special Attention.#
}
?DataFrame
